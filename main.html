<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Cell Defense - 웨이브 모드</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    @keyframes bgGreenGlow {
    0% { background-position: 0 0, 0 0, 0 0; }
    50% { background-position: 30px 30px, 20px 20px, -20px -20px; }
    100% { background-position: 0 0, 0 0, 0 0; }
  }


    @keyframes bgFloat {
    0%   { background-position: 0 0, 0 0, 0 0; }
    50%  { background-position: 40px 60px, -30px -50px, 20px 40px; }
    100% { background-position: 0 0, 0 0, 0 0; }
  }

    body {
      margin: 0;
      padding: 0;
      background-color: #2a2a2a;
      background-image:
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px);
      background-size: 32px 32px;
      font-family: 'Press Start 2P', monospace;
      color: #eee;
      display: flex;
      justify-content: center;
      padding-top: 20px;
      overflow: hidden;
    }

    .container {
      /* 캔버스(800) + 사이드바 양쪽(200×2) + 컬럼 간격(12×2) = 1224px
         여기에 padding(16×2) + border(8×2) 합 48px을 합쳐서 총 1272px */
      width: 1272px;
      box-sizing: border-box;
      padding: 16px;
      border: 8px solid #4a8;
      background-color: #1a1a1a;
      box-shadow: inset 0 0 0 4px #030;
    }

    .content-row {
      display: flex;
      gap: 12px;
    }

    .sidebar {
      width: 200px;           /* 160 → 200px로 넓힘 */
      box-sizing: border-box;
      padding: 12px;
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      font-size: 12px;
      line-height: 1.4;
    }
    .sidebar h2 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #4a8;
      text-shadow: 1px 1px 0 #030;
    }
    .sidebar ul, .sidebar ol {
      margin: 8px 0;
      padding-left: 16px;
    }
    .sidebar hr {
      border: none;
      border-top: 1px solid #4a8;
      margin: 8px 0;
    }

    .main {
      flex: 1;                /* 중앙에 남은 공간을 전부 할당 */
      display: flex;
      flex-direction: column;
      align-items: center;    /* 캔버스 등 중앙 정렬 */
    }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .header img {
      width: 64px;
      height: 64px;
      image-rendering: pixelated;
      border: 4px solid #4a8;
    }
    .header h1 {
      margin: 0;
      font-size: 28px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
    }

    #ui {
      width: 800px;           /* 캔버스 너비와 맞춰서 중앙 고정 */
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      margin-bottom: 20px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    #ui > div, #ui span {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ui button {
      background-color: #4a8;
      color: #000;
      border: 4px solid #030;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      image-rendering: pixelated;
    }
    #ui button:hover {
      background-color: #6af;
    }
    #ui button:disabled {
      background-color: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }

    .game-area {
      position: relative;
      width: 800px;           /* 캔버스 고정 폭 */
    }
    #gameCanvas {
      display: block;
      width: 800px;
      height: 600px;
      border: 8px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      image-rendering: pixelated;
    }
    #waveBanner {
      position: absolute;
      top: 20px;
      width: 100%;
      font-size: 32px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    #cellInfo {
      position: absolute;
      top: 8px;
      left: calc(50% + 550px);
      width: 250px;
      padding: 8px;
      background: rgba(17,17,17,0.9);
      border: 2px solid #4a8;
      font-size: 15px;
      line-height: 1.4;
      color: #eee;
      z-index: 10;
    }
    #cellInfo .description {
      font-size: 14px;
      font-family: 'Poppins';
      color: #ccc;
      margin: 4px 0;
    }
    #cellInfo button {
      margin-top: 6px;
      background: #4a8;
      color: #000;
      border: 2px solid #030;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #cellInfo button:disabled {
      background: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="content-row">

      <!-- 왼쪽 사이드바 -->
      <aside class="sidebar left">
        <h2>세포 가이드</h2>
        <ul>
          <li>기본 세포: 단일 타겟 집중 공격</li>
          <li>뉴런 세포: 범위 내 전격 공격</li>
          <li>식물 세포: 경로 차단·방어장 생성</li>
        </ul>
        <br>
        <div id="cellCountInfo" style="margin-top:12px; color:#8f8;font-size: 13px;">세포 수: 0 / 20</div>
      </aside>

      <!-- 중앙 메인 영역 -->
      <main class="main">
        <div class="header">
          <img src="images/Unrevr.png" alt="UNREVR 로고">
          <h1>Cell Defense - 웨이브 모드</h1>
        </div>

        <div id="ui">
          <div>ATP: <span id="atp">200</span></div>
          <div>체력: <span id="health">5</span></div>
          <div>웨이브: <span id="wave">1</span></div>
          <button id="basicBtn">기본세포(50)</button>
          <button id="neuronBtn">뉴런(80)</button>
          <button id="plantBtn">식물세포(60)</button>
          <button id="startBtn">다음 웨이브</button>
          <span id="timer"></span>
          <span id="score">Score: 0</span>
        </div>

        <div class="game-area">
          <canvas id="gameCanvas" width="800" height="600"></canvas>
          <div id="waveBanner"></div>
          <div id="cellInfo"></div>
        </div>
      </main>
    </div>
  </div>

  <script>

const selectedMap = localStorage.getItem('selectedMap') || 'lab';
const mapConfigs = {
  lab: {
    lines: [200, 400],
    style: {
      backgroundColor: '#2a2a2a',
      backgroundImage: `
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px)
      `,
      backgroundSize: '32px 32px',
      animation: ''
    },
    gimmick: {
      name: "기본 실험실",
      description: "기본 밸런스 맵. 추가 효과 없음"
    }
  },
  greenhouse: {
    lines: [150, 300, 450],
    style: {
      backgroundColor: '#1b2e1b',
      backgroundImage: `
        radial-gradient(circle, rgba(144,238,144,0.15) 2px, transparent 2px),
        linear-gradient(135deg, rgba(50,120,50,0.1) 25%, transparent 25%),
        linear-gradient(225deg, rgba(50,120,50,0.1) 25%, transparent 25%)
      `,
      backgroundSize: '60px 60px',
      animation: 'bgGreenGlow 20s linear infinite'
    },
    gimmick: {
      name: "온실",
      description: "식물세포 강화: HP +30%, 방어범위 +20%",
      plantHpMultiplier: 1.3,
      plantRangeBonus: 1.2,
      upgradeDiscount: 0.9
    }
  },
  cytosol: {
    lines: [250, 350],
    style: {
      backgroundColor: '#0f1a2a',
      backgroundImage: `
        radial-gradient(circle, rgba(173,216,230,0.15) 3px, transparent 3px),
        radial-gradient(circle, rgba(0,255,255,0.1) 2px, transparent 2px),
        linear-gradient(90deg, rgba(0,128,255,0.05) 1px, transparent 1px)
      `,
      backgroundSize: '80px 80px, 40px 40px, 100px 100px',
      animation: 'bgFloat 25s ease-in-out infinite'
    },
    gimmick: {
      name: "세포질",
      description: "적 속도 증가, 뉴런 스턴 효과 약화, 기본 세포 사거리 증가",
      enemySpeedMultiplier: 1.1,
      neuronStunResistance: true,
      basicRangeBonus: 1.1
    }
  }
};

  const mapConfig = mapConfigs[selectedMap] || mapConfigs.lab;

    // 배경 이미지 객체
  const bgImg = new Image();
  bgImg.src = mapConfig.backgroundSrc;

  // 가이드 라인 위치 override
  const lines = mapConfig.lines;

const style = mapConfig.style;
Object.assign(document.body.style, {
  backgroundColor: style.backgroundColor,
  backgroundImage: style.backgroundImage,
  backgroundSize: style.backgroundSize,
  animation: style.animation
});




// 스크립트 최상단, 혹은 초기화 부분에 한 번만 추가
const infoPanel = document.getElementById('cellInfo');
infoPanel.addEventListener('click', e => {
  // 업그레이드 버튼 클릭
  if (e.target.id === 'infoUpgradeBtn') {
    if (!selectedUpgradeTarget) return;
    const cell = selectedUpgradeTarget;
    const cost = getUpgradeCost(cell);
    if (ATP < cost) return;
    ATP -= cost;
    cell.spent += cost;
    cell.upgrade = (cell.upgrade || 0) + 1;
    if (cell.type === 'basic') {
      cell.damage += 2; cell.range  += 10;
    } else if (cell.type === 'neuron') {
      cell.damage += 1.5; cell.range  += 8;
    } else {
      cell.hp    += 30;  cell.maxHp += 30;
    }
    // 업그레이드 후에도 선택 유지
    updateUIButtons();
    updateCellInfo();
  }

 // 판매 버튼 클릭
 // ▶ 판매 버튼
  if (e.target.id === 'sellBtn') {
    if (!selectedUpgradeTarget) return;
    const cell = selectedUpgradeTarget;
    const refund = Math.floor(cell.spent / 2);
    ATP += refund;
    // 셀 제거
    cells.splice(cells.indexOf(cell), 1);
    selectedUpgradeTarget = null;
    updateUIButtons();
    updateCellInfo();
    updateCellCount(); // 세포 수 갱신 및 콘솔 출력
  }

  // 진화 버튼 클릭
  if (e.target.id === 'evolveBtn') {
    if (!selectedUpgradeTarget) return;
    const evoCost = getEvolutionCost(selectedUpgradeTarget);
    if (ATP < evoCost) return;
    ATP -= evoCost;
    selectedUpgradeTarget.spent += evoCost;
    const c = selectedUpgradeTarget;
    showEvolutionEffect(c);
    c.upgrade = 6;
    updateUIButtons();
    updateCellInfo();
  }
});


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const waveBanner = document.getElementById('waveBanner');
const atpDisplay = document.getElementById('atp');
const healthDisplay = document.getElementById('health');
const waveDisplay = document.getElementById('wave');
const basicBtn = document.getElementById('basicBtn');
const neuronBtn = document.getElementById('neuronBtn');
const plantBtn = document.getElementById('plantBtn');
const startBtn = document.getElementById('startBtn');
const timerDisplay = document.getElementById('timer');
const scoreDisplay = document.getElementById('score');

// 이미지 로드
const imgCell = new Image();
imgCell.src = 'images/Cell.png';
const imgPlant = new Image();
imgPlant.src = 'images/plant.png';
const imgNeuron = new Image();
imgNeuron.src = 'images/new.png';
const superBacteriaFrames = [];
const covidFrames = [];
const cancerFrames = [];
const cancerFrames2 = [];

const imgVirusSprite = new Image();
imgVirusSprite.src = 'images/세균.png';  // virus 대체 이미지
const imgParasite     = new Image();
imgParasite.src     = 'images/기생충.png';        // parasite 이미지
const imgBacteriophageSprite     = new Image();
imgBacteriophageSprite.src     = 'images/박테리오파지.png';          // bacteria 이미지

for (let i = 0; i <= 3; i++) {
  const img = new Image();
  img.src = `images/superbacteria${i}.png`;
  superBacteriaFrames.push(img);
}

for (let i = 190; i <= 192; i++) {
  const img = new Image();
  img.src = `images/covid${i}.png`;
  covidFrames.push(img);
}

for (let i = 10; i <= 12; i++) {
  const img = new Image();
  img.src = `images/finalboss${i}.png`;
  cancerFrames.push(img);
}

for (let i = 13; i <= 14; i++) {
  const img = new Image();
  img.src = `images/finalboss${i}.png`;
  cancerFrames2.push(img);
}


// ↓ baseCellTypes 아래에 추가
// 기존 cellDescriptions 대신 이걸로 교체하세요
const cellDescriptions = {
  basic:  
    '기본 세포(Animal Cell): 핵(nucleus), 미토콘드리아(mitochondria), 소포체(ER), 골지체(Golgi), 리소좀(lysosome) 등으로 이루어져 있으며, 단일 표적에 식균 작용(phagocytosis) 기반 공격을 합니다.',
  neuron: 
    '뉴런(Neuron): 핵, 미토콘드리아, 소포체, 골지체 외에 시냅스 소포(synaptic vesicle)를 포함하며, 광역 전기 신호를 발사해 주변 모든 적에게 전격 공격을 가합니다.',
  plant:  
    '식물 세포(Plant Cell): 세포벽(cell wall), 엽록체(chloroplast), 중앙액포(vacuole), 미토콘드리아, 골지체 등으로 구성되어 있으며, 적의 이동을 차단하고 주변에 지속적인 방어장(Barrier)을 형성합니다.'
};


// — 적 이름·설명 매핑 —
const enemyNames = {
  virus:      '바이러스',
  parasite:   '기생충',
  bacteria:   '세균',
  superVirus: '슈퍼 바이러스',
  covidVirus: '코로나 바이러스',
  cancerCell: '암세포'
};
const enemyDescriptions = {
  virus:      '속도 빠르나 체력이 낮은 바이러스: 단일 목표에 빠르게 돌진합니다.',
  parasite:   '체력 높고 느리지만, 방어선을 오래 지연시키는 기생충입니다.',
  bacteria:   '속도·체력 모두 평균적인 균형형 적입니다.',
  superVirus: '5웨이브 보스: 고속·고화력 공격을 퍼붓는 슈퍼 바이러스입니다.',
  covidVirus: '10웨이브 보스: 주변 세포를 죽이는 코로나 바이러스입니다.',
  cancerCell: '15웨이브 보스: 한 번으로 끝나지 않습니다.'
};

// 선택된 업그레이드 대상, 셀 배치 중, 적 클릭용
let selectedEnemy = null;

let ATP = 500;
let health = 5;
let wave = 0;
let enemiesToSpawn = 0;
let enemiesSpawned = 0;
let waveInProgress = false;
let interWave = true;
let spawnDone = false;
let interSeconds = 30;
let interTimer = null;
let spawnInterval = null;
let selectedCell = null;
let selectedUpgradeTarget = null;
let mouseX = 0, mouseY = 0;
let score = 0;
let firstWave = true;
let waveStartLock = false;
let revived = false; // 부활 여부
let reviveCount = 0; // 부활 횟수
const ADMIN_KEY = 'unrevr2025!!';

const cells = [];
const enemies = [];
const projectiles = [];

const baseCellTypes = {
  basic:  { damage:10, range:60, cooldownMax:50, cost:50, projectileSpeed:8 },
  neuron: { damage:8, range:100, cooldownMax:120, cost:80 },
  plant:  { hp:300, cost:60 }
};

const enemyTypes = [
  { type:'virus',   hp:30, speed:1.2, color:'#d22', size:20 },
  { type:'parasite',hp:50, speed:0.5, color:'#720072', size:30 },
  { type:'bacteria',hp:40, speed:0.9, color:'#ff6', size:25 }
];

function canEvolve(cell) {
  if (!cell) return false;
  if (cell.type === 'basic' && cell.upgrade === 5) return true;
  if (cell.type === 'neuron' && cell.upgrade === 5) return true;
  if (cell.type === 'plant' && cell.upgrade === 5) return true;
  return false;
}

function showEvolutionEffect(cell) {
  const rings = [30, 40];           // 두 번 반짝일 반지 크기
  rings.forEach((startR, idx) => {
    const effectFrames = 30;
    let frame = 0;
    function effect() {
      ctx.save();
      ctx.globalAlpha = 1 - frame / effectFrames;
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, startR + frame * 2, 0, Math.PI * 2);
      ctx.strokeStyle = idx === 0 ? '#fff700' : '#00f6ff';
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.restore();
      frame++;
      if (frame < effectFrames) requestAnimationFrame(effect);
    }
    setTimeout(effect, idx * 100); // 0ms, 100ms 뒤 두 번째 고리
  });
}

function getCellDisplayName(cell) {
  if (cell.type === 'basic' && cell.upgrade >= 6) return '백혈구';
  if (cell.type === 'neuron' && cell.upgrade >= 6) return '시냅스 뉴런';
  if (cell.type === 'plant' && cell.upgrade >= 6) return '점액 세포벽';
  if (cell.type === 'basic') return '기본 세포';
  if (cell.type === 'neuron') return '뉴런';
  if (cell.type === 'plant') return '세포벽';
  return '';
}

function getEvolutionCost(cell) {
  // 예: 마지막 업그레이드 비용의 2배
  const lastUpgradeCost = getUpgradeCost(cell);
  return lastUpgradeCost * 2;
}

function updateUIButtons() {
const bCost = getPlacementCost('basic');
const nCost = getPlacementCost('neuron');
const pCost = getPlacementCost('plant');

basicBtn.textContent  = `기본세포(${bCost})`;
neuronBtn.textContent = `뉴런(${nCost})`;
plantBtn.textContent  = `식물세포(${pCost})`;

basicBtn.disabled   = ATP < bCost;
neuronBtn.disabled  = ATP < nCost;
plantBtn.disabled   = ATP < pCost;


  // 버튼 자체는 항상 보이지만, interWave가 아닐 땐 숨김
  startBtn.style.display = interWave ? 'inline-block' : 'none';
  timerDisplay.style.display = interWave ? 'inline-block' : 'none';

  atpDisplay.textContent      = ATP;
  healthDisplay.textContent   = Math.floor(health);
  waveDisplay.textContent     = wave;
  scoreDisplay.textContent    = `Score: ${score}`;
}


basicBtn.onclick = () => selectCell('basic');
neuronBtn.onclick = () => selectCell('neuron');
plantBtn.onclick = () => selectCell('plant');
function selectCell(type) {
  selectedCell = type;
  selectedUpgradeTarget = null;
  [basicBtn, neuronBtn, plantBtn].forEach(b => b.style.background = '#0f0');
  document.getElementById(type+'Btn').style.background = '#0c0';
  updateUIButtons();
}

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
});
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  if (selectedCell) {
    const cost = getPlacementCost(selectedCell);
    if (ATP < cost) return;

    // 라인 근처 판정 (±15px)
    const isOnLine = lines.some(lineY => Math.abs(y - lineY) <= 15);

    // 설치 제한 로직
    if (
      (selectedCell === 'plant' && !isOnLine) || // 식물세포는 라인 위에만
      ((selectedCell === 'basic' || selectedCell === 'neuron') && isOnLine) // 기본/뉴런은 라인 위에 설치 불가
    ) {
      window.alert(
        selectedCell === 'plant'
          ? '식물세포는 라인 위에만 설치할 수 있습니다!'
          : '기본/뉴런 세포는 라인에 설치할 수 없습니다!'
      );
      return;
    }

    if (cells.length >= 20) {
      window.alert('세포는 최대 20개까지만 설치할 수 있습니다!');
      selectedCell = null; // 세포 클릭 취소
      updateUIButtons();
      return;
    }

    const cell = {
      x, y,
      type: selectedCell,
      cooldown: 0,
      hp: baseCellTypes[selectedCell].hp,
      maxHp: baseCellTypes[selectedCell].hp,
      damage: baseCellTypes[selectedCell].damage || 0,
      range: baseCellTypes[selectedCell].range || 0,
      upgrade: 0,
      spent: cost
    };

    // gimmick 적용
    const gimmick = mapConfig.gimmick || {};
    if (cell.type === 'plant') {
      if (gimmick.plantHpMultiplier) {
        cell.hp *= gimmick.plantHpMultiplier;
        cell.maxHp *= gimmick.plantHpMultiplier;
      }
      if (gimmick.plantRangeBonus) {
        cell.range *= gimmick.plantRangeBonus;
      }
    }
    if (cell.type === 'basic' && gimmick.basicRangeBonus) {
      cell.range *= gimmick.basicRangeBonus;
    }

    // 배열에 추가
    cells.push(cell);
    ATP -= cost;
    selectedCell = null;
    updateUIButtons();
    updateCellInfo();
    updateCellCount(); // 세포 수 갱신 및 콘솔 출력
    return;
  }

  selectedUpgradeTarget = null;
  selectedEnemy = null;
  for (const en of enemies) {
    if (Math.hypot(e.clientX - canvas.getBoundingClientRect().left - en.x,
                   e.clientY - canvas.getBoundingClientRect().top - en.y)
        <= en.size) {
      selectedEnemy = en;
      updateUIButtons();
      updateCellInfo();
      return;
    }
  }

  selectedUpgradeTarget = null;
  for (const c of cells) {
    const dx = x - c.x;
    const dy = y - c.y;
    const hit = (c.type==='plant') ? Math.abs(dx)<=20 && Math.abs(dy)<=30 : Math.hypot(dx,dy)<=20;
    if (hit) { selectedUpgradeTarget = c; break; }
  }
  updateUIButtons();
  updateCellInfo();
  updateCellCount(); // 세포 수 갱신 및 콘솔 출력
});

// 현재 세포 수를 세는 변수와 함수
let CellCount = 0;
function updateCellCount() {
  CellCount = cells.length;
  console.log('현재 세포 수:', CellCount);
  // 왼쪽 바 표시도 함께 갱신
  const el = document.getElementById('cellCountInfo');
  if (el) el.textContent = `세포 수: ${CellCount} / 20`;
}

// --- 게임 시작 시 한 번 표시 ---
updateCellCount();

startBtn.onclick = () => {
  // interWave 중이 아니거나 이미 락 걸려 있으면 무시
  if (!interWave || waveStartLock) return;

  // 클릭 첫 순간에 락
  waveStartLock = true;

  // 기존 로직
  if (interTimer) {
    clearInterval(interTimer);
    interTimer = null;
  }
  wave++;
  interWave = false;
  waveInProgress = true;
  updateUIButtons();
  spawnWave();
};

function updateCellInfo() {
  const info = document.getElementById('cellInfo');
  
  // 1) 셀 배치 선택 시
  if (selectedCell) {
    const type = selectedCell;
    const names = { basic:'기본 세포', neuron:'뉴런', plant:'식물 세포' };
    const tpl  = baseCellTypes[type];
    const cost = getPlacementCost(type);
    let html = `
      <div><strong>설치 후보 ▶ ${names[type]}</strong></div>
      <div class="description">${cellDescriptions[type]}</div>
      <div>공격력: ${tpl.damage||0}</div>
      <div>사거리: ${tpl.range||0}</div>
      ${type==='plant'?`<div>체력: ${tpl.hp}</div>`:``}
      <div>설치 비용: ${cost}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 2) 적 클릭 시
  if (selectedEnemy) {
    const e    = selectedEnemy;
    const name = enemyNames[e.type];
    const desc = enemyDescriptions[e.type];
    let html = `
      <div><strong>적 ▶ ${name}</strong></div>
      <div class="description">${desc}</div>
      <div>체력: ${Math.round(e.hp)} / ${e.maxHp}</div>
      <div>속도: ${e.speed.toFixed(2)}</div>
      <div>공격력: ${e.damageToCell}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 3) 업그레이드 대상 클릭 시 (기존 로직)
  if (!selectedUpgradeTarget) {
    info.innerHTML = '';
    return;
  }
  const c    = selectedUpgradeTarget;
const type = c.type;
const names= { basic:'기본 세포', neuron:'뉴런', plant:'식물 세포' };
const evolveNames = { basic:'백혈구', neuron:'시냅스 뉴런', plant:'점액 세포벽' };
const evolveDescs = {
  basic: '백혈구: 공격속도 증가, 투사체가 흰색, 적을 30% 확률로 둔화시킴',
  neuron: '시냅스 뉴런: 전격 이펙트가 파란색, 적을 감전(스턴)시킴',
  plant: '점액 세포벽: 파괴 시 주변 적 둔화'
};
const curr = { damage:c.damage||0, range:c.range||0, hp:c.maxHp||0 };
const next = { ...curr };
if (type==='basic')     { next.damage+=2;  next.range+=10; }
else if (type==='neuron'){ next.damage+=1.5;next.range+=8; }
else /* plant */        { next.hp+=30; }
const cost = getUpgradeCost(c);

// 진화 버튼
  if (c.upgrade === 5) {
    // 진화 비용 계산
    const evoCost = getEvolutionCost(c);
    info.innerHTML = `
      <div><strong>진화 ▶ ${evolveNames[type]}</strong></div>
      <div class="description">${evolveDescs[type]}</div>
      <div>진화 비용: ${evoCost} ATP</div>
      <button id="evolveBtn" ${ATP < evoCost ? 'disabled' : ''}>진화! (${evoCost})</button>
    `;
  } else {
  // 업그레이드 버튼
  info.innerHTML = `
    <div><strong>종류: ${c.upgrade >= 6 ? evolveNames[type] : names[type]}</strong></div>
    <div class="description">${c.upgrade >= 6 ? evolveDescs[type] : cellDescriptions[type]}</div>
    <div>공격력: ${curr.damage} → ${next.damage}</div>
    <div>사거리: ${curr.range} → ${next.range}</div>
    ${type==='plant'?`<div>체력: ${curr.hp.toFixed(2)} → ${next.hp.toFixed(2)}</div>`:``}
    <button id="infoUpgradeBtn" ${ATP<cost||c.upgrade>=6?'disabled':''}>업그레이드 (${cost})</button>
  `;
}
   const sellRefund = Math.floor(c.spent / 2);
   info.innerHTML += `
     <button id="sellBtn">판매 (환불 ${sellRefund} ATP)</button>
   `;
}

function spawnWave() {
  spawnDone = false;
  enemiesSpawned = 0;
  // 5의 배수 웨이브면 보스 1마리 + 일반 적 (보스 포함 총 n+1마리)
  if (wave % 5 === 0) {
    enemiesToSpawn = 5 + wave * 2; // 일반 적 수
    enemiesToSpawn += 1;           // 보스 1마리 추가
  } else {
    enemiesToSpawn = 5 + wave * 2;
  }
  updateUIButtons();

  // --- 중간보스 경고 및 세포 제거 (10웨이브) ---
  if (wave === 10) {
    showWaveBanner('중간보스 등장!');
    setTimeout(() => {
      showWaveBanner('랜덤 세포 3개 제거');
    },1000)
    // 1초 후 중간보스 등장(연출)
    setTimeout(() => {
      // 세포 3개 랜덤 제거 (이펙트 적용)
      if (cells.length > 0) {
        const shuffled = cells.slice().sort(() => Math.random() - 0.5);
        for (let i = 0; i < Math.min(3, shuffled.length); i++) {
          const cell = shuffled[i];
          cell.disappearEffect = 30; // 30프레임(0.5초) 이펙트
        }
        updateCellCount();
        updateCellInfo();
      }
      // 실제 적 스폰 시작
      spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
    }, 1000);
    return; // 아래 spawnInterval은 실행하지 않음
  }

  showWaveBanner(`Wave ${wave}`);
  spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
}

function spawnEnemy() {
  if (enemiesSpawned >= enemiesToSpawn) {
    clearInterval(spawnInterval);
    waveInProgress = false;
    spawnDone = true;
    return;
  }
  // 5의 배수 웨이브, 마지막 적이면 보스 등장
  if (wave % 5 === 0 && enemiesSpawned === enemiesToSpawn - 1) {
    const y = lines[Math.floor(Math.random() * lines.length)];
    // 10웨이브, 15웨이브, 그 외 보스 타입 분기
    let bossType = 'superVirus';
    let bossHp = 200 + wave * 20;
    let bossDmg = 3 + Math.floor(wave/5);
    if (wave === 10) {
      bossType = 'covidVirus';
      bossHp = 850; // 중간보스 체력 강화
      bossDmg = 10;  // 중간보스 공격력 강화
    } else if (wave === 15) {
      bossType = 'cancerCell';
      bossHp = 1200; // 15웨이브 보스 체력(적절히 조정)
      bossDmg = 15;  // 15웨이브 보스 공격력(적절히 조정)
    }
    const enemy = {
      type: bossType,
      x:0, y,
      hp: bossHp,
      maxHp: bossHp,
      speed: 0.8,
      color: '#ff0',
      size: 50,
      damageToCell: bossDmg,
      blocked: false, blockTimer: 0,
      animFrame: 0,
      animTick: 0
    };
    if (mapConfig.gimmick?.enemySpeedMultiplier) {
      enemy.speed *= mapConfig.gimmick.enemySpeedMultiplier;
    }
    enemies.push(enemy);

  } else {
    const base = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
    const y = lines[Math.floor(Math.random()*lines.length)];
    // wave 6부터 체력 보너스 적용
    let hpBonus = 0;
    if (wave >= 6) {
      hpBonus = (wave - 5) * 7; // 6웨이브부터 웨이브마다 +7씩 추가
    }
    enemies.push({
      type: base.type,
      x:0, y,
      hp: base.hp + wave*5 + hpBonus,
      maxHp: base.hp + wave*5 + hpBonus,
      speed: base.speed + wave*0.05,
      color: base.color,
      size: base.size,
      damageToCell: 1 + Math.floor(wave/3),
      blocked: false, blockTimer: 0
    });
  }
  enemiesSpawned++;
}


// 설치 비용: 같은 타입 세포 개수에 비례해 +10%씩 상승
function getPlacementCost(type) {
  const base = baseCellTypes[type].cost;
  const count = cells.filter(c => c.type === type).length;
  let cost = Math.max(Math.floor(base * (1 + count * 0.1)), base);

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}


// 업그레이드 비용: 레벨에 비례해 +50%씩 상승
function getUpgradeCost(cell) {
  const base = 50;
  const lvl  = cell.upgrade || 0;
  let cost = Math.floor(base * (1 + lvl * 0.5));

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}



function startInterWave() {
  interWave = true;
  waveStartLock = false;
  ATP += (100 + wave * 50);

  // 웨이브 15가 끝나면 게임 종료
  if (wave >= 15) {
    showWaveBanner(`모든 웨이브 클리어!\n최종 점수: ${score}`);
    // 버튼 비활성화
    startBtn.style.display = 'none';
    timerDisplay.style.display = 'none';
    // 5초 뒤 main.html로 이동
    setTimeout(() => {
      window.location.href = 'index.html';
    }, 5000);
    return;
  }

  // Upgrade Time UI 제거
  timerDisplay.textContent = '';
  updateUIButtons();

  // 웨이브 자동 시작 타이머 제거
  // 기존 interTimer, setInterval 등 모두 생략
  // 사용자가 startBtn을 눌러야 다음 웨이브가 시작됨
}



function showWaveBanner(txt) {
  waveBanner.textContent = txt;
  waveBanner.style.opacity = 1;
  setTimeout(() => waveBanner.style.opacity = 0, 2000);
}

function drawHealthBar(x,y,w,h,hp,mh) { ctx.fillStyle='black';ctx.fillRect(x,y,w,h);ctx.fillStyle='lime';ctx.fillRect(x,y,w*(hp/mh),h);ctx.strokeStyle='white';ctx.strokeRect(x,y,w,h); }
function drawEnemyStats(e) { ctx.fillStyle='white';ctx.font='12px Arial';ctx.fillText(`DMG:${e.damageToCell}`,e.x-15,e.y-e.size-6); }
function drawElectricArc(x, y, ts, isBlue) {
  ctx.strokeStyle = isBlue ? '#00f6ff' : 'yellow';
  ctx.lineWidth=3;
  ts.forEach(t=>{
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(t.x,t.y); ctx.stroke();
  });
}
function drawCellImage(cell) {
  ctx.save();
  if (cell.disappearEffect) {
    ctx.globalAlpha = cell.disappearEffect / 30;
  }
  // 진화 이미지 분기
  if (cell.type === 'plant') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgPlantEvo, cell.x - 20, cell.y - 30, 40, 60);
    } else {
      ctx.drawImage(imgPlant, cell.x - 20, cell.y - 30, 40, 60);
    }
  } else if (cell.type === 'basic') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgCellEvo, cell.x - 20, cell.y - 20, 40, 40);
    } else {
      ctx.drawImage(imgCell, cell.x - 20, cell.y - 20, 40, 40);
    }
  } else if (cell.type === 'neuron') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgNeuronEvo, cell.x - 20, cell.y - 20, 40, 40);
    } else {
      ctx.drawImage(imgNeuron, cell.x - 20, cell.y - 20, 40, 40);
    }
  }
  ctx.restore();
}

// 이미지 로드 부분에 진화 이미지 추가
const imgCellEvo = new Image();
imgCellEvo.src = 'images/Cellevo.png';
const imgPlantEvo = new Image();
imgPlantEvo.src = 'images/plantevo.png';
const imgNeuronEvo = new Image();
imgNeuronEvo.src = 'images/newevo.png';

let isInvincible = false;
let invincibleTimer = 0;

function loop() {
  // 무적 상태 관리 및 시각 효과
  if (isInvincible) {
    invincibleTimer--;
    if (invincibleTimer <= 0) {
      isInvincible = false;
    }
    // 무적 시 캔버스 테두리 깜빡임 효과
    ctx.save();
    ctx.strokeStyle = invincibleTimer % 30 < 15 ? '#ff0' : '#fff';
    ctx.lineWidth = 10;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  // disappearEffect 처리 및 세포 제거 (이펙트 끝난 세포만)
  for (let i = cells.length - 1; i >= 0; i--) {
    const cell = cells[i];
    if (cell.disappearEffect) {
      cell.disappearEffect--;
      if (cell.disappearEffect <= 0) {
        cells.splice(i, 1);
        continue;
      }
    }
  }

  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,800,600);
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth   = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();

  if (selectedCell) {
   ctx.save();
   ctx.globalAlpha = 0.4;
   const px = mouseX, py = mouseY;
   // 기물 이미지
   drawCellImage({ type: selectedCell, x: px, y: py });
   // 사거리 원
   const range = baseCellTypes[selectedCell].range || 0;
   if (range) {
     ctx.strokeStyle = 'white';
     ctx.beginPath();
     ctx.arc(px, py, range, 0, Math.PI * 2);
     ctx.stroke();
   }
   // 레벨 표시 (초기 Lv.0)
   ctx.fillStyle = '#4a8';
   ctx.font = 'bold 12px Arial';
   ctx.textAlign = 'center';
   ctx.fillText('Lv.0', px, py - 16);
   ctx.restore();
 }

  // 1) 라인(가이드선) 표시
  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();

  // 2) 세포 그리기
  cells.forEach(cell => {
    drawCellImage(cell);

    // 이름
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(getCellDisplayName(cell), cell.x, cell.y - 30);

    // 레벨
    ctx.fillStyle = '#4a8';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`Lv.${cell.upgrade}`, cell.x, cell.y - 16);

    // 식물 세포 HP 바 (소수점 둘째자리까지)
    if (cell.type === 'plant') {
      drawHealthBar(cell.x - 20, cell.y + 35, 40, 6, cell.hp, cell.maxHp);
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${cell.hp.toFixed(2)} / ${cell.maxHp.toFixed(2)}`, cell.x, cell.y + 48);
      ctx.restore();
    }

    // 선택 강조
    if (cell === selectedUpgradeTarget) {
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      if (cell.type === 'plant') {
        ctx.strokeRect(cell.x - 24, cell.y - 34, 48, 68);
      } else {
        ctx.beginPath();
        ctx.arc(cell.x, cell.y, 26, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();

    // ② 공격 범위 표시: cell.range 만큼 흰색 점선 원
    if (cell.range) {
      ctx.save();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, cell.range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }
  });

  // 세포 공격
  cells.forEach(cell => {
  if(cell.type==='plant') return;
  if(cell.cooldown>0){
    cell.cooldown--;
    // 뉴런의 경우 쿨타임 동안에도 arcTargets을 유지
    if(cell.type === 'neuron' && cell.arcTargets) {
      // 아무 것도 하지 않음(arcTargets 유지)
    }
    return;
  }
  const type = baseCellTypes[cell.type];
  if(cell.type==='basic'){
    let target=null, minD=Infinity;
    enemies.forEach(e=>{
      const d=Math.hypot(e.x-cell.x,e.y-cell.y);
      if(d<=cell.range && d<minD){ minD=d; target=e; }
    });
    if(target){
      cell.cooldown = cell.upgrade >=  6 ? 30 : type.cooldownMax;
      projectiles.push({
        x:cell.x, y:cell.y, target, damage:cell.damage, speed:type.projectileSpeed,
        isWhiteBlood: cell.upgrade >= 6
      });
    }
  } else if(cell.type==='neuron'){
    const hits = enemies.filter(e => Math.hypot(e.x-cell.x, e.y-cell.y) <= cell.range);
    if (hits.length) {
      hits.forEach(e => {
        e.hp -= cell.damage;
        if (!mapConfig.gimmick?.neuronStunResistance && cell.upgrade >= 6) {
          e.stun = 10;
        }
      });
      cell.arcTargets = hits; // 쿨타임 동안 유지
      cell.cooldown = type.cooldownMax;
      cell.isBlueArc = cell.upgrade >= 6;
    } else {
      cell.arcTargets = null; // 맞은 적이 없으면 arcTargets 해제
    }
  }
});

enemies.forEach(e => {
  // ── 1) 이동 속도 세팅 ──
  let moveSpeed = e.speed;
  if(e.stun && e.stun > 0) {
    moveSpeed = 0;
    e.stun--;
  }
  if(e.slow && e.slow > 0) {
    moveSpeed *= 0.5;
    e.slow--;
  }
  // ── 2) 충돌 검사 ──
  let didCollide = false;
  for (const cell of cells) {
    const dx = e.x - cell.x;
    const dy = e.y - cell.y;

    // (1) 식물 세포 충돌 → 뒤로 튕기기
    if (
      cell.type === 'plant' &&
      Math.abs(dx) <= 20 + e.size &&   // ← 세포벽(식물) 가로 반폭 20
      Math.abs(dy) <= 30 + e.size * 0.6 // ← 세포벽(식물) 세로 반높이 30
    ) {
      // 식물에 데미지
      cell.hp -= e.damageToCell;

      if (cell.hp <= 0) {
        // 5레벨 이상이면 주변 적 슬로우
        const slowRadius = cell.range || 60;
        if (cell.upgrade >= 6) {
          enemies.forEach(e2 => {
            if (Math.hypot(e2.x - cell.x, e2.y - cell.y) < slowRadius) {
              e2.slow = 60;
            }
          });
        }
        // 죽은 식물 세포는 즉시 배열에서 제거 (이펙트는 별도 처리)
        const idx = cells.indexOf(cell);
        if (idx !== -1) {
          cell.disappearEffect = 30; // 죽은 세포 효과
          cells.splice(idx, 1);
        }
        updateCellCount();
        updateCellInfo();
        break;
      }
      // 적을 뒤로 밀기 (막힘 효과)
      e.x -= moveSpeed; // ← 이동을 취소(혹은 더 강하게 밀고 싶으면 *2 등)
      didCollide = true;
      break; // 충돌 시 for문 탈출
    }
  }
  // ── 3) 충돌 없으면 앞으로 이동 ──
  if (!didCollide) {
    e.x += moveSpeed;
  }

  // ── 4) 렌더링 & 강조 & HP바 ──
  if (e.type === 'superVirus') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % superBacteriaFrames.length;
    }
    ctx.drawImage(
      superBacteriaFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'covidVirus') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % covidFrames.length;
    }
    ctx.drawImage(
      covidFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'cancerCell') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % cancerFrames.length;
    }
    ctx.drawImage(
      cancerFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'virus') {
    // virus 타입 → 세균 이미지
    ctx.drawImage(
      imgVirusSprite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'parasite') {
    // parasite 타입 → 기생충 이미지
    ctx.drawImage(
      imgParasite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'bacteria') {
    // bacteria 타입 → 박테리오파지 이미지
    ctx.drawImage(
      imgBacteriophageSprite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  }
  // 15웨이브 보스 2페이즈 구현
  else if (e.type === 'cancerCell2') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % cancerFrames2.length;
    }
    ctx.drawImage(
      cancerFrames2[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  }

  // 선택 강조
  if (e === selectedEnemy) {
    ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth   = 3;
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, e.size + 4, e.size * 0.6 + 4, 0, 0, Math.PI * 2);
      ctx.stroke();
    ctx.restore();
  }

  drawHealthBar(e.x - e.size, e.y - e.size - 10, e.size*2, 6, e.hp, e.maxHp);
  // 체력 소수점 둘째자리까지 표시
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`${e.hp.toFixed(2)} / ${e.maxHp.toFixed(2)}`, e.x, e.y - e.size - 14);
  ctx.restore();
  drawEnemyStats(e);
}); 




  // 투사체
for(let i=projectiles.length-1;i>=0;i--){
  const p=projectiles[i];
  if(!p.target||p.target.hp<=0){ projectiles.splice(i,1); continue; }
  const dx=p.target.x-p.x, dy=p.target.y-p.y, d=Math.hypot(dx,dy);
  if(d<p.speed){
    p.target.hp-=p.damage;
    // 백혈구화 슬로우 효과
    if(p.isWhiteBlood && Math.random()<0.3) p.target.slow = 40;
    projectiles.splice(i,1);
  } else {
    p.x+=(dx/d)*p.speed; p.y+=(dy/d)*p.speed;
    ctx.fillStyle = p.isWhiteBlood ? '#ff0000' : '#fff';
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
  }
}
  cells.forEach(cell=>{
    if(cell.type==='neuron'&&cell.arcTargets&&cell.cooldown>0)
      drawElectricArc(cell.x,cell.y,cell.arcTargets, cell.isBlueArc);
  });

  // 적 제거·체력 소진
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.hp<=0){ 
      // 15웨이브 보스 2페이즈 구현
      if (e.type === 'cancerCell' && wave === 15 && !e.secondPhase) {
        // 2페이즈 보스 소환
        showWaveBanner('아직 끝이 아니다! 더 강한 암세포 등장!');
        const y = e.y;
        const boss2 = {
          type: 'cancerCell2',
          x: 0, y: y,
          hp: 1800,
          maxHp: 1800,
          speed: 1.0,
          color: '#f0f',
          size: 60,
          damageToCell: 20,
          blocked: false, blockTimer: 0,
          animFrame: 0,
          animTick: 0,
          secondPhase: true
        };
        enemies.push(boss2);
      }
      console.log('죽은 적군 제거', e);
      enemies.splice(i,1); 
      score+=10; 
      ATP+=20;
      scoreDisplay.textContent = `Score: ${score}`;
      atpDisplay.textContent = ATP;
      continue; // 죽은 적은 더 이상 처리하지 않음
    }
    if (e.x > 800 && e.hp > 0) {
      console.log('살아있는 적군이 끝 도달', e);
      if (!isInvincible) {
        const dmg = e.damageToCell * (e.hp / e.maxHp);
        health = Math.max(0, health - dmg);
        healthDisplay.textContent = health.toFixed(2);
      }
      enemies.splice(i, 1);
      if (health <= 0) {
        if (reviveCount < 2) {
          let reviveCost = reviveCount === 0 ? 500 : 750;
          let reviveMsg = reviveCount === 0 ? '코인 500개로 부활하시겠습니까?' : '코인 750개로 부활하시겠습니까?';
          showWaveBanner('관리자 키를 입력해야 부활할 수 있습니다!');
          // 입력창 및 버튼 생성
          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100vw';
          overlay.style.height = '100vh';
          overlay.style.background = 'rgba(0,0,0,0.7)';
          overlay.style.zIndex = 2000;
          overlay.style.display = 'flex';
          overlay.style.flexDirection = 'column';
          overlay.style.justifyContent = 'center';
          overlay.style.alignItems = 'center';

          const msg = document.createElement('div');
          msg.textContent = reviveMsg;
          msg.style.color = '#fff';
          msg.style.fontSize = '22px';
          msg.style.marginBottom = '18px';
          overlay.appendChild(msg);

          const input = document.createElement('input');
          input.type = 'password';
          input.placeholder = '관리자 키 입력';
          input.style.fontSize = '20px';
          input.style.padding = '8px';
          input.style.marginBottom = '12px';
          overlay.appendChild(input);

          const reviveBtn = document.createElement('button');
          reviveBtn.textContent = '부활하기';
          reviveBtn.style.fontSize = '20px';
          reviveBtn.style.padding = '12px 32px';
          reviveBtn.style.background = '#ff0';
          reviveBtn.style.color = '#000';
          reviveBtn.style.border = '4px solid #4a8';
          reviveBtn.style.cursor = 'pointer';
          overlay.appendChild(reviveBtn);

          const errorMsg = document.createElement('div');
          errorMsg.style.color = '#ff4444';
          errorMsg.style.fontSize = '16px';
          errorMsg.style.marginTop = '10px';
          overlay.appendChild(errorMsg);

          // 포기하기 버튼 추가
          const giveUpBtn = document.createElement('button');
          giveUpBtn.textContent = '포기하기';
          giveUpBtn.style.fontSize = '18px';
          giveUpBtn.style.padding = '10px 28px';
          giveUpBtn.style.background = '#888';
          giveUpBtn.style.color = '#fff';
          giveUpBtn.style.border = '2px solid #333';
          giveUpBtn.style.marginTop = '18px';
          giveUpBtn.style.cursor = 'pointer';
          overlay.appendChild(giveUpBtn);

          giveUpBtn.onclick = () => {
            overlay.innerHTML = `<div style='color:#fff;font-size:22px;margin-bottom:12px;'>Score: ${score}</div><div style='color:#ff0;font-size:20px;'>메인 화면으로 이동합니다...</div>`;
            setTimeout(() => {
              window.location.href = 'index.html';
            }, 2000);
          };




          
          document.body.appendChild(overlay);
          cancelAnimationFrame(loopId);

          reviveBtn.onclick = () => {
            if (input.value !== ADMIN_KEY) {
              errorMsg.textContent = '관리자 키가 올바르지 않습니다!';
              return;
            }
            // 코인 차감 없이 부활
            reviveCount++;
            overlay.remove();
            health = 5;
            healthDisplay.textContent = health.toFixed(2);
            showWaveBanner('생명력이 회복되었습니다!');
            // 무적 상태 3초
            isInvincible = true;
            invincibleTimer = 180; // 60fps 기준 3초
            loopId = requestAnimationFrame(loop);
          };
          return;
        } else {
          showWaveBanner('게임 종료!');
          // 점수 표시 등 추가 코드가 있다면 여기에
          return;
        }
      }
    }
    if (e.x > 800 && e.hp <= 0) {
      console.log('hp 0 이하인데 끝 도달', e);
    }
  }

  if (!interWave && !waveInProgress && spawnDone && enemies.length === 0) {
    startInterWave();
  }

  loopId = requestAnimationFrame(loop);
}

interWave = true;
updateUIButtons();
waveDisplay.textContent = wave;
scoreDisplay.textContent = `Score: ${score}`;
loop();

  </script>
</body>
</html>