<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Cell Defense - ì›¨ì´ë¸Œ ëª¨ë“œ</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    @keyframes bgGreenGlow {
    0% { background-position: 0 0, 0 0, 0 0; }
    50% { background-position: 30px 30px, 20px 20px, -20px -20px; }
    100% { background-position: 0 0, 0 0, 0 0; }
  }


    @keyframes bgFloat {
    0%   { background-position: 0 0, 0 0, 0 0; }
    50%  { background-position: 40px 60px, -30px -50px, 20px 40px; }
    100% { background-position: 0 0, 0 0, 0 0; }
  }





    body {
      margin: 0;
      padding: 0;
      background-color: #2a2a2a;
      background-image:
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px);
      background-size: 32px 32px;
      font-family: 'Press Start 2P', monospace;
      color: #eee;
      display: flex;
      justify-content: center;
      padding-top: 20px;
    }

    .container {
      /* ìº”ë²„ìŠ¤(800) + ì‚¬ì´ë“œë°” ì–‘ìª½(200Ã—2) + ì»¬ëŸ¼ ê°„ê²©(12Ã—2) = 1224px
         ì—¬ê¸°ì— padding(16Ã—2) + border(8Ã—2) í•© 48pxì„ í•©ì³ì„œ ì´ 1272px */
      width: 1272px;
      box-sizing: border-box;
      padding: 16px;
      border: 8px solid #4a8;
      background-color: #1a1a1a;
      box-shadow: inset 0 0 0 4px #030;
    }

    .content-row {
      display: flex;
      gap: 12px;
    }

    .sidebar {
      width: 200px;           /* 160 â†’ 200pxë¡œ ë„“í˜ */
      box-sizing: border-box;
      padding: 12px;
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      font-size: 12px;
      line-height: 1.4;
    }
    .sidebar h2 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #4a8;
      text-shadow: 1px 1px 0 #030;
    }
    .sidebar ul, .sidebar ol {
      margin: 8px 0;
      padding-left: 16px;
    }
    .sidebar hr {
      border: none;
      border-top: 1px solid #4a8;
      margin: 8px 0;
    }

    .main {
      flex: 1;                /* ì¤‘ì•™ì— ë‚¨ì€ ê³µê°„ì„ ì „ë¶€ í• ë‹¹ */
      display: flex;
      flex-direction: column;
      align-items: center;    /* ìº”ë²„ìŠ¤ ë“± ì¤‘ì•™ ì •ë ¬ */
    }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .header img {
      width: 64px;
      height: 64px;
      image-rendering: pixelated;
      border: 4px solid #4a8;
    }
    .header h1 {
      margin: 0;
      font-size: 28px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
    }

    #ui {
      width: 800px;           /* ìº”ë²„ìŠ¤ ë„ˆë¹„ì™€ ë§ì¶°ì„œ ì¤‘ì•™ ê³ ì • */
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      margin-bottom: 20px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    #ui > div, #ui span {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ui button {
      background-color: #4a8;
      color: #000;
      border: 4px solid #030;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      image-rendering: pixelated;
    }
    #ui button:hover {
      background-color: #6af;
    }
    #ui button:disabled {
      background-color: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }

    .game-area {
      position: relative;
      width: 800px;           /* ìº”ë²„ìŠ¤ ê³ ì • í­ */
    }
    #gameCanvas {
      display: block;
      width: 800px;
      height: 600px;
      border: 8px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      image-rendering: pixelated;
    }
    #waveBanner {
      position: absolute;
      top: 20px;
      width: 100%;
      font-size: 32px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    #cellInfo {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 200px;
      padding: 8px;
      background: rgba(17,17,17,0.9);
      border: 2px solid #4a8;
      font-size: 12px;
      line-height: 1.4;
      color: #eee;
      z-index: 10;
    }
    #cellInfo .description {
      font-size: 10px;
      color: #ccc;
      margin: 4px 0;
    }
    #cellInfo button {
      margin-top: 6px;
      background: #4a8;
      color: #000;
      border: 2px solid #030;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #cellInfo button:disabled {
      background: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="content-row">

      <!-- ì™¼ìª½ ì‚¬ì´ë“œë°” -->
      <aside class="sidebar left">
        <h2>ì„¸í¬ ê°€ì´ë“œ</h2>
        <ul>
          <li>ê¸°ë³¸ ì„¸í¬: ë‹¨ì¼ íƒ€ê²Ÿ ì§‘ì¤‘ ê³µê²©</li>
          <li>ë‰´ëŸ° ì„¸í¬: ë²”ìœ„ ë‚´ ì „ê²© ê³µê²©</li>
          <li>ì‹ë¬¼ ì„¸í¬: ê²½ë¡œ ì°¨ë‹¨Â·ë°©ì–´ì¥ ìƒì„±</li>
        </ul>
      </aside>

      <!-- ì¤‘ì•™ ë©”ì¸ ì˜ì—­ -->
      <main class="main">
        <div class="header">
          <img src="images/Unrevr.png" alt="UNREVR ë¡œê³ ">
          <h1>Cell Defense - ì›¨ì´ë¸Œ ëª¨ë“œ</h1>
        </div>

        <div id="ui">
          <div>ATP: <span id="atp">200</span></div>
          <div>ì²´ë ¥: <span id="health">5</span></div>
          <div>ì›¨ì´ë¸Œ: <span id="wave">1</span></div>
          <button id="basicBtn">ê¸°ë³¸ì„¸í¬(50)</button>
          <button id="neuronBtn">ë‰´ëŸ°(80)</button>
          <button id="plantBtn">ì‹ë¬¼ì„¸í¬(60)</button>
          <button id="startBtn">ë‹¤ìŒ ì›¨ì´ë¸Œ</button>
          <span id="timer"></span>
          <span id="score">Score: 0</span>
          <span id="highScore">HighScore: 0</span>
        </div>

        <div class="game-area">
          <canvas id="gameCanvas" width="800" height="600"></canvas>
          <div id="waveBanner"></div>
          <div id="cellInfo"></div>
        </div>
      </main>

      <!-- ì˜¤ë¥¸ìª½ ì‚¬ì´ë“œë°” -->
      <aside class="sidebar right">
        <h2>ì›¨ì´ë¸Œ ì •ë³´</h2>
        <div>í˜„ì¬ ì›¨ì´ë¸Œ: <span id="wave">1</span></div>
        <div>ë‹¤ìŒ ë³´ìŠ¤: ìŠˆí¼ ë°”ì´ëŸ¬ìŠ¤</div>
        <hr>
        <h2>ë¦¬ë”ë³´ë“œ</h2>
        <ol id="leaderboard">
          <li>í”Œë ˆì´ì–´1 â€“ 1200</li>
          <li>í”Œë ˆì´ì–´2 â€“ 950</li>
          <li>í”Œë ˆì´ì–´3 â€“ 730</li>
        </ol>
      </aside>

    </div>
  </div>

  <script>

const selectedMap = localStorage.getItem('selectedMap') || 'lab';
const mapConfigs = {
  lab: {
    lines: [200, 400],
    style: {
      backgroundColor: '#2a2a2a',
      backgroundImage: `
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px)
      `,
      backgroundSize: '32px 32px',
      animation: ''
    },
    gimmick: {
      name: "ê¸°ë³¸ ì‹¤í—˜ì‹¤",
      description: "ê¸°ë³¸ ë°¸ëŸ°ìŠ¤ ë§µ. ì¶”ê°€ íš¨ê³¼ ì—†ìŒ"
    }
  },
  greenhouse: {
    lines: [150, 300, 450],
    style: {
      backgroundColor: '#1b2e1b',
      backgroundImage: `
        radial-gradient(circle, rgba(144,238,144,0.15) 2px, transparent 2px),
        linear-gradient(135deg, rgba(50,120,50,0.1) 25%, transparent 25%),
        linear-gradient(225deg, rgba(50,120,50,0.1) 25%, transparent 25%)
      `,
      backgroundSize: '60px 60px',
      animation: 'bgGreenGlow 20s linear infinite'
    },
    gimmick: {
      name: "ì˜¨ì‹¤",
      description: "ì‹ë¬¼ì„¸í¬ ê°•í™”: HP +30%, ë°©ì–´ë²”ìœ„ +20%",
      plantHpMultiplier: 1.3,
      plantRangeBonus: 1.2,
      upgradeDiscount: 0.9
    }
  },
  cytosol: {
    lines: [250, 350],
    style: {
      backgroundColor: '#0f1a2a',
      backgroundImage: `
        radial-gradient(circle, rgba(173,216,230,0.15) 3px, transparent 3px),
        radial-gradient(circle, rgba(0,255,255,0.1) 2px, transparent 2px),
        linear-gradient(90deg, rgba(0,128,255,0.05) 1px, transparent 1px)
      `,
      backgroundSize: '80px 80px, 40px 40px, 100px 100px',
      animation: 'bgFloat 25s ease-in-out infinite'
    },
    gimmick: {
      name: "ì„¸í¬ì§ˆ",
      description: "ì  ì†ë„ ì¦ê°€, ë‰´ëŸ° ìŠ¤í„´ íš¨ê³¼ ì•½í™”, ê¸°ë³¸ ì„¸í¬ ì‚¬ê±°ë¦¬ ì¦ê°€",
      enemySpeedMultiplier: 1.1,
      neuronStunResistance: true,
      basicRangeBonus: 1.1
    }
  }
};

  const mapConfig = mapConfigs[selectedMap] || mapConfigs.lab;

    // ë°°ê²½ ì´ë¯¸ì§€ ê°ì²´
  const bgImg = new Image();
  bgImg.src = mapConfig.backgroundSrc;

  // ê°€ì´ë“œ ë¼ì¸ ìœ„ì¹˜ override
  const lines = mapConfig.lines;

const style = mapConfig.style;
Object.assign(document.body.style, {
  backgroundColor: style.backgroundColor,
  backgroundImage: style.backgroundImage,
  backgroundSize: style.backgroundSize,
  animation: style.animation
});




// ìŠ¤í¬ë¦½íŠ¸ ìµœìƒë‹¨, í˜¹ì€ ì´ˆê¸°í™” ë¶€ë¶„ì— í•œ ë²ˆë§Œ ì¶”ê°€
const infoPanel = document.getElementById('cellInfo');
infoPanel.addEventListener('click', e => {
  // ì—…ê·¸ë ˆì´ë“œ ë²„íŠ¼ í´ë¦­
  if (e.target.id === 'infoUpgradeBtn') {
    if (!selectedUpgradeTarget) return;
    const cell = selectedUpgradeTarget;
    const cost = getUpgradeCost(cell);
    if (ATP < cost) return;
    ATP -= cost;
    cell.spent += cost;
    cell.upgrade = (cell.upgrade || 0) + 1;
    if (cell.type === 'basic') {
      cell.damage += 2; cell.range  += 10;
    } else if (cell.type === 'neuron') {
      cell.damage += 1.5; cell.range  += 8;
    } else {
      cell.hp    += 30;  cell.maxHp += 30;
    }
    // ì—…ê·¸ë ˆì´ë“œ í›„ì—ë„ ì„ íƒ ìœ ì§€
    updateUIButtons();
    updateCellInfo();
  }

 // íŒë§¤ ë²„íŠ¼ í´ë¦­
 // â–¶ íŒë§¤ ë²„íŠ¼
  if (e.target.id === 'sellBtn') {
    if (!selectedUpgradeTarget) return;
    const cell = selectedUpgradeTarget;
    const refund = Math.floor(cell.spent / 2);
    ATP += refund;
    // ì…€ ì œê±°
    cells.splice(cells.indexOf(cell), 1);
    selectedUpgradeTarget = null;
    updateUIButtons();
    updateCellInfo();
  }

  // ì§„í™” ë²„íŠ¼ í´ë¦­
  if (e.target.id === 'evolveBtn') {
    if (!selectedUpgradeTarget) return;
    const evoCost = getEvolutionCost(selectedUpgradeTarget);
    if (ATP < evoCost) return;
    ATP -= evoCost;
    selectedUpgradeTarget.spent += evoCost;
    const c = selectedUpgradeTarget;
    showEvolutionEffect(c);
    c.upgrade = 6;
    updateUIButtons();
    updateCellInfo();
  }
});


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const waveBanner = document.getElementById('waveBanner');
const atpDisplay = document.getElementById('atp');
const healthDisplay = document.getElementById('health');
const waveDisplay = document.getElementById('wave');
const basicBtn = document.getElementById('basicBtn');
const neuronBtn = document.getElementById('neuronBtn');
const plantBtn = document.getElementById('plantBtn');
const startBtn = document.getElementById('startBtn');
const timerDisplay = document.getElementById('timer');
const scoreDisplay = document.getElementById('score');
const highScoreDisplay = document.getElementById('highScore');

// ì´ë¯¸ì§€ ë¡œë“œ
const imgCell = new Image();
imgCell.src = 'images/cell.png';
const imgPlant = new Image();
imgPlant.src = 'images/plant.png';
const imgNeuron = new Image();
imgNeuron.src = 'images/new.png';
const superBacteriaFrames = [];

const imgVirusSprite = new Image();
imgVirusSprite.src = 'images/ì„¸ê· .png';  // virus ëŒ€ì²´ ì´ë¯¸ì§€
const imgParasite     = new Image();
imgParasite.src     = 'images/ê¸°ìƒì¶©.png';        // parasite ì´ë¯¸ì§€
const imgBacteriophageSprite     = new Image();
imgBacteriophageSprite.src     = 'images/ë°•í…Œë¦¬ì˜¤íŒŒì§€.png';          // bacteria ì´ë¯¸ì§€

for (let i = 0; i <= 3; i++) {
  const img = new Image();
  img.src = `images/superbacteria${i}.png`;
  superBacteriaFrames.push(img);
}

// â†“ baseCellTypes ì•„ë˜ì— ì¶”ê°€
// ê¸°ì¡´ cellDescriptions ëŒ€ì‹  ì´ê±¸ë¡œ êµì²´í•˜ì„¸ìš”
const cellDescriptions = {
  basic:  
    'ê¸°ë³¸ ì„¸í¬(Animal Cell): í•µ(nucleus), ë¯¸í† ì½˜ë“œë¦¬ì•„(mitochondria), ì†Œí¬ì²´(ER), ê³¨ì§€ì²´(Golgi), ë¦¬ì†Œì¢€(lysosome) ë“±ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ë‹¨ì¼ í‘œì ì— ì‹ê·  ì‘ìš©(phagocytosis) ê¸°ë°˜ ê³µê²©ì„ í•©ë‹ˆë‹¤.',
  neuron: 
    'ë‰´ëŸ°(Neuron): í•µ, ë¯¸í† ì½˜ë“œë¦¬ì•„, ì†Œí¬ì²´, ê³¨ì§€ì²´ ì™¸ì— ì‹œëƒ…ìŠ¤ ì†Œí¬(synaptic vesicle)ë¥¼ í¬í•¨í•˜ë©°, ê´‘ì—­ ì „ê¸° ì‹ í˜¸ë¥¼ ë°œì‚¬í•´ ì£¼ë³€ ëª¨ë“  ì ì—ê²Œ ì „ê²© ê³µê²©ì„ ê°€í•©ë‹ˆë‹¤.',
  plant:  
    'ì‹ë¬¼ ì„¸í¬(Plant Cell): ì„¸í¬ë²½(cell wall), ì—½ë¡ì²´(chloroplast), ì¤‘ì•™ì•¡í¬(vacuole), ë¯¸í† ì½˜ë“œë¦¬ì•„, ê³¨ì§€ì²´ ë“±ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ì ì˜ ì´ë™ì„ ì°¨ë‹¨í•˜ê³  ì£¼ë³€ì— ì§€ì†ì ì¸ ë°©ì–´ì¥(Barrier)ì„ í˜•ì„±í•©ë‹ˆë‹¤.'
};


// â€” ì  ì´ë¦„Â·ì„¤ëª… ë§¤í•‘ â€”
const enemyNames = {
  virus:      'ë°”ì´ëŸ¬ìŠ¤',
  parasite:   'ê¸°ìƒì¶©',
  bacteria:   'ì„¸ê· ',
  superVirus: 'ìŠˆí¼ ë°”ì´ëŸ¬ìŠ¤',
  monster:    'ëª¬ìŠ¤í„°'
};
const enemyDescriptions = {
  virus:      'ì†ë„ ë¹ ë¥´ë‚˜ ì²´ë ¥ì´ ë‚®ì€ ë°”ì´ëŸ¬ìŠ¤: ë‹¨ì¼ ëª©í‘œì— ë¹ ë¥´ê²Œ ëŒì§„í•©ë‹ˆë‹¤.',
  parasite:   'ì²´ë ¥ ë†’ê³  ëŠë¦¬ì§€ë§Œ, ë°©ì–´ì„ ì„ ì˜¤ë˜ ì§€ì—°ì‹œí‚¤ëŠ” ê¸°ìƒì¶©ì…ë‹ˆë‹¤.',
  bacteria:   'ì†ë„Â·ì²´ë ¥ ëª¨ë‘ í‰ê· ì ì¸ ê· í˜•í˜• ì ì…ë‹ˆë‹¤.',
  superVirus: '5ì›¨ì´ë¸Œ ë³´ìŠ¤: ê³ ì†Â·ê³ í™”ë ¥ ê³µê²©ì„ í¼ë¶“ëŠ” ìŠˆí¼ ë°”ì´ëŸ¬ìŠ¤ì…ë‹ˆë‹¤.',
  monster:    'ìµœì¢… 10ì›¨ì´ë¸Œ ë³´ìŠ¤: ì••ë„ì  ì²´ë ¥ê³¼ ê³µê²©ë ¥ì˜ ëª¬ìŠ¤í„° êµ°ë‹¨ì…ë‹ˆë‹¤.'
};

// ì„ íƒëœ ì—…ê·¸ë ˆì´ë“œ ëŒ€ìƒ, ì…€ ë°°ì¹˜ ì¤‘, ì  í´ë¦­ìš©
let selectedEnemy = null;

let ATP =20000;
let health = 5;
let wave = 0;
let enemiesToSpawn = 0;
let enemiesSpawned = 0;
let waveInProgress = false;
let interWave = true;
let spawnDone = false;
let interSeconds = 30;
let interTimer = null;
let spawnInterval = null;
let selectedCell = null;
let selectedUpgradeTarget = null;
let mouseX = 0, mouseY = 0;
let score = 0;
let firstWave = true;
let waveStartLock = false;
let highScore = parseInt(localStorage.getItem('gdh_highScore')) || 0;
highScoreDisplay.textContent = highScore;

const cells = [];
const enemies = [];
const projectiles = [];

const baseCellTypes = {
  basic:  { damage:50, range:60, cooldownMax:50, cost:50, projectileSpeed:8 },
  neuron: { damage:50, range:100, cooldownMax:120, cost:80 },
  plant:  { hp:500, cost:60 }
};

const enemyTypes = [
  { type:'virus',   hp:30, speed:1.2, color:'#d22', size:20 },
  { type:'parasite',hp:50, speed:0.5, color:'#720072', size:30 },
  { type:'bacteria',hp:40, speed:0.9, color:'#ff6', size:25 }
];

function canEvolve(cell) {
  if (!cell) return false;
  if (cell.type === 'basic' && cell.upgrade === 5) return true;
  if (cell.type === 'neuron' && cell.upgrade === 5) return true;
  if (cell.type === 'plant' && cell.upgrade === 5) return true;
  return false;
}

function showEvolutionEffect(cell) {
  const rings = [30, 40];           // ë‘ ë²ˆ ë°˜ì§ì¼ ë°˜ì§€ í¬ê¸°
  rings.forEach((startR, idx) => {
    const effectFrames = 30;
    let frame = 0;
    function effect() {
      ctx.save();
      ctx.globalAlpha = 1 - frame / effectFrames;
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, startR + frame * 2, 0, Math.PI * 2);
      ctx.strokeStyle = idx === 0 ? '#fff700' : '#00f6ff';
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.restore();
      frame++;
      if (frame < effectFrames) requestAnimationFrame(effect);
    }
    setTimeout(effect, idx * 100); // 0ms, 100ms ë’¤ ë‘ ë²ˆì§¸ ê³ ë¦¬
  });
}

function getCellDisplayName(cell) {
  if (cell.type === 'basic' && cell.upgrade >= 6) return 'ë°±í˜ˆêµ¬';
  if (cell.type === 'neuron' && cell.upgrade >= 6) return 'ì‹œëƒ…ìŠ¤ ë‰´ëŸ°';
  if (cell.type === 'plant' && cell.upgrade >= 6) return 'ì ì•¡ ì„¸í¬ë²½';
  if (cell.type === 'basic') return 'ê¸°ë³¸ ì„¸í¬';
  if (cell.type === 'neuron') return 'ë‰´ëŸ°';
  if (cell.type === 'plant') return 'ì„¸í¬ë²½';
  return '';
}

function getEvolutionCost(cell) {
  // ì˜ˆ: ë§ˆì§€ë§‰ ì—…ê·¸ë ˆì´ë“œ ë¹„ìš©ì˜ 2ë°°
  const lastUpgradeCost = getUpgradeCost(cell);
  return lastUpgradeCost * 2;
}

function updateUIButtons() {
const bCost = getPlacementCost('basic');
const nCost = getPlacementCost('neuron');
const pCost = getPlacementCost('plant');

basicBtn.textContent  = `ê¸°ë³¸ì„¸í¬(${bCost})`;
neuronBtn.textContent = `ë‰´ëŸ°(${nCost})`;
plantBtn.textContent  = `ì‹ë¬¼ì„¸í¬(${pCost})`;

basicBtn.disabled   = ATP < bCost;
neuronBtn.disabled  = ATP < nCost;
plantBtn.disabled   = ATP < pCost;


  // ë²„íŠ¼ ìì²´ëŠ” í•­ìƒ ë³´ì´ì§€ë§Œ, interWaveê°€ ì•„ë‹ ë• ìˆ¨ê¹€
  startBtn.style.display = interWave ? 'inline-block' : 'none';
  timerDisplay.style.display = interWave ? 'inline-block' : 'none';

  atpDisplay.textContent      = ATP;
  healthDisplay.textContent   = health;
  waveDisplay.textContent     = wave;
  scoreDisplay.textContent    = `Score: ${score}`;
  highScoreDisplay.textContent= `HighScore: ${highScore}`;
}


basicBtn.onclick = () => selectCell('basic');
neuronBtn.onclick = () => selectCell('neuron');
plantBtn.onclick = () => selectCell('plant');
function selectCell(type) {
  selectedCell = type;
  selectedUpgradeTarget = null;
  [basicBtn, neuronBtn, plantBtn].forEach(b => b.style.background = '#0f0');
  document.getElementById(type+'Btn').style.background = '#0c0';
  updateUIButtons();
}

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
});
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  if (selectedCell) {
    const cost = getPlacementCost(selectedCell);
    if (ATP < cost) return;
    
      const cell = {
      x, y,
      type: selectedCell,
      cooldown: 0,
      hp: baseCellTypes[selectedCell].hp,
      maxHp: baseCellTypes[selectedCell].hp,
      damage: baseCellTypes[selectedCell].damage || 0,
      range: baseCellTypes[selectedCell].range || 0,
      upgrade: 0,
      spent: cost
    };

    // ğŸ”½ ì—¬ê¸°ì— gimmick ì ìš© ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ ğŸ”½
    const gimmick = mapConfig.gimmick || {};
    if (cell.type === 'plant') {
      if (gimmick.plantHpMultiplier) {
        cell.hp *= gimmick.plantHpMultiplier;
        cell.maxHp *= gimmick.plantHpMultiplier;
      }
      if (gimmick.plantRangeBonus) {
        cell.range *= gimmick.plantRangeBonus;
      }
    }
    if (cell.type === 'basic' && gimmick.basicRangeBonus) {
      cell.range *= gimmick.basicRangeBonus;
    }

    // ë°°ì—´ì— ì¶”ê°€
    cells.push(cell);
    ATP -= cost;
    selectedCell = null;
    updateUIButtons();
    updateCellInfo();
    return;
  }

  selectedUpgradeTarget = null;
  selectedEnemy = null;
  for (const en of enemies) {
    if (Math.hypot(e.clientX - canvas.getBoundingClientRect().left - en.x,
                   e.clientY - canvas.getBoundingClientRect().top - en.y)
        <= en.size) {
      selectedEnemy = en;
      updateUIButtons();
      updateCellInfo();
      return;
    }
  }

  selectedUpgradeTarget = null;
  for (const c of cells) {
    const dx = x - c.x;
    const dy = y - c.y;
    const hit = (c.type==='plant') ? Math.abs(dx)<=20 && Math.abs(dy)<=30 : Math.hypot(dx,dy)<=20;
    if (hit) { selectedUpgradeTarget = c; break; }
  }
  updateUIButtons();
  updateCellInfo();
});


startBtn.onclick = () => {
  // interWave ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ ì´ë¯¸ ë½ ê±¸ë ¤ ìˆìœ¼ë©´ ë¬´ì‹œ
  if (!interWave || waveStartLock) return;

  // í´ë¦­ ì²« ìˆœê°„ì— ë½
  waveStartLock = true;

  // ê¸°ì¡´ ë¡œì§
  if (interTimer) {
    clearInterval(interTimer);
    interTimer = null;
  }
  wave++;
  interWave = false;
  waveInProgress = true;
  updateUIButtons();
  spawnWave();
};

function updateCellInfo() {
  const info = document.getElementById('cellInfo');
  
  // 1) ì…€ ë°°ì¹˜ ì„ íƒ ì‹œ
  if (selectedCell) {
    const type = selectedCell;
    const names = { basic:'ê¸°ë³¸ ì„¸í¬', neuron:'ë‰´ëŸ°', plant:'ì‹ë¬¼ ì„¸í¬' };
    const tpl  = baseCellTypes[type];
    const cost = getPlacementCost(type);
    let html = `
      <div><strong>ì„¤ì¹˜ í›„ë³´ â–¶ ${names[type]}</strong></div>
      <div class="description">${cellDescriptions[type]}</div>
      <div>ê³µê²©ë ¥: ${tpl.damage||0}</div>
      <div>ì‚¬ê±°ë¦¬: ${tpl.range||0}</div>
      ${type==='plant'?`<div>ì²´ë ¥: ${tpl.hp}</div>`:``}
      <div>ì„¤ì¹˜ ë¹„ìš©: ${cost}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 2) ì  í´ë¦­ ì‹œ
  if (selectedEnemy) {
    const e    = selectedEnemy;
    const name = enemyNames[e.type];
    const desc = enemyDescriptions[e.type];
    let html = `
      <div><strong>ì  â–¶ ${name}</strong></div>
      <div class="description">${desc}</div>
      <div>ì²´ë ¥: ${Math.round(e.hp)} / ${e.maxHp}</div>
      <div>ì†ë„: ${e.speed.toFixed(2)}</div>
      <div>ê³µê²©ë ¥: ${e.damageToCell}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 3) ì—…ê·¸ë ˆì´ë“œ ëŒ€ìƒ í´ë¦­ ì‹œ (ê¸°ì¡´ ë¡œì§)
  if (!selectedUpgradeTarget) {
    info.innerHTML = '';
    return;
  }
  // ...existing code...
const c    = selectedUpgradeTarget;
const type = c.type;
const names= { basic:'ê¸°ë³¸ ì„¸í¬', neuron:'ë‰´ëŸ°', plant:'ì‹ë¬¼ ì„¸í¬' };
const evolveNames = { basic:'ë°±í˜ˆêµ¬', neuron:'ì‹œëƒ…ìŠ¤ ë‰´ëŸ°', plant:'ì ì•¡ ì„¸í¬ë²½' };
const evolveDescs = {
  basic: 'ë°±í˜ˆêµ¬: ê³µê²©ì†ë„ ì¦ê°€, íˆ¬ì‚¬ì²´ê°€ í°ìƒ‰, ì ì„ 30% í™•ë¥ ë¡œ ë‘”í™”ì‹œí‚´',
  neuron: 'ì‹œëƒ…ìŠ¤ ë‰´ëŸ°: ì „ê²© ì´í™íŠ¸ê°€ íŒŒë€ìƒ‰, ì ì„ ê°ì „(ìŠ¤í„´)ì‹œí‚´',
  plant: 'ì ì•¡ ì„¸í¬ë²½: íŒŒê´´ ì‹œ ì£¼ë³€ ì  ë‘”í™”'
};
const curr = { damage:c.damage||0, range:c.range||0, hp:c.maxHp||0 };
const next = { ...curr };
if (type==='basic')     { next.damage+=2;  next.range+=10; }
else if (type==='neuron'){ next.damage+=1.5;next.range+=8; }
else /* plant */        { next.hp+=30; }
const cost = getUpgradeCost(c);

// ì§„í™” ë²„íŠ¼
  if (c.upgrade === 5) {
    // ì§„í™” ë¹„ìš© ê³„ì‚°
    const evoCost = getEvolutionCost(c);
    info.innerHTML = `
      <div><strong>ì§„í™” â–¶ ${evolveNames[type]}</strong></div>
      <div class="description">${evolveDescs[type]}</div>
      <div>ì§„í™” ë¹„ìš©: ${evoCost} ATP</div>
      <button id="evolveBtn" ${ATP < evoCost ? 'disabled' : ''}>ì§„í™”! (${evoCost})</button>
    `;
  } else {
  // ì—…ê·¸ë ˆì´ë“œ ë²„íŠ¼
  info.innerHTML = `
    <div><strong>ì¢…ë¥˜: ${c.upgrade >= 6 ? evolveNames[type] : names[type]}</strong></div>
    <div class="description">${c.upgrade >= 6 ? evolveDescs[type] : cellDescriptions[type]}</div>
    <div>ê³µê²©ë ¥: ${curr.damage} â†’ ${next.damage}</div>
    <div>ì‚¬ê±°ë¦¬: ${curr.range} â†’ ${next.range}</div>
    ${type==='plant'?`<div>ì²´ë ¥: ${curr.hp} â†’ ${next.hp}</div>`:``}
    <button id="infoUpgradeBtn" ${ATP<cost||c.upgrade>=6?'disabled':''}>ì—…ê·¸ë ˆì´ë“œ (${cost})</button>
  `;
}
   const sellRefund = Math.floor(c.spent / 2);
   info.innerHTML += `
     <button id="sellBtn">íŒë§¤ (í™˜ë¶ˆ ${sellRefund} ATP)</button>
   `;
}

function spawnWave() {
  spawnDone = false;
  enemiesSpawned = 0;
  // 5ì˜ ë°°ìˆ˜ ì›¨ì´ë¸Œë©´ ë³´ìŠ¤ 1ë§ˆë¦¬ + ì¼ë°˜ ì  (ë³´ìŠ¤ í¬í•¨ ì´ n+1ë§ˆë¦¬)
  if (wave % 5 === 0) {
    enemiesToSpawn = 5 + wave * 2; // ì¼ë°˜ ì  ìˆ˜
    enemiesToSpawn += 1;           // ë³´ìŠ¤ 1ë§ˆë¦¬ ì¶”ê°€
  } else {
    enemiesToSpawn = 5 + wave * 2;
  }
  updateUIButtons();
  showWaveBanner(`Wave ${wave}`);
  spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
}

function spawnEnemy() {
  if (enemiesSpawned >= enemiesToSpawn) {
    clearInterval(spawnInterval);
    waveInProgress = false;
    spawnDone = true;
    return;
  }
  // 5ì˜ ë°°ìˆ˜ ì›¨ì´ë¸Œ, ë§ˆì§€ë§‰ ì ì´ë©´ ë³´ìŠ¤ ë“±ì¥
  if (wave % 5 === 0 && enemiesSpawned === enemiesToSpawn - 1) {
    const y = lines[Math.floor(Math.random() * lines.length)];
    const enemy = {
      type: wave===10 ? 'monster' : 'superVirus',
      x:0, y,
      hp: 200 + wave*20,
      maxHp: 200 + wave*20,
      speed: 0.8,
      color: '#ff0',
      size: 50,
      damageToCell: 3 + Math.floor(wave/5),
      blocked: false, blockTimer: 0,
      animFrame: 0,
      animTick: 0
    };
    
  if (mapConfig.gimmick?.enemySpeedMultiplier) {
    enemy.speed *= mapConfig.gimmick.enemySpeedMultiplier;
  }

  enemies.push(enemy);

  } else {
    const base = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
    const y = lines[Math.floor(Math.random()*lines.length)];
    enemies.push({
      type: base.type,
      x:0, y,
      hp: base.hp + wave*5,
      maxHp: base.hp + wave*5,
      speed: base.speed + wave*0.05,
      color: base.color,
      size: base.size,
      damageToCell: 1 + Math.floor(wave/3),
      blocked: false, blockTimer: 0
    });
  }
  enemiesSpawned++;
}


// ì„¤ì¹˜ ë¹„ìš©: ê°™ì€ íƒ€ì… ì„¸í¬ ê°œìˆ˜ì— ë¹„ë¡€í•´ +10%ì”© ìƒìŠ¹
function getPlacementCost(type) {
  const base = baseCellTypes[type].cost;
  const count = cells.filter(c => c.type === type).length;
  let cost = Math.max(Math.floor(base * (1 + count * 0.1)), base);

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}


// ì—…ê·¸ë ˆì´ë“œ ë¹„ìš©: ë ˆë²¨ì— ë¹„ë¡€í•´ +50%ì”© ìƒìŠ¹
function getUpgradeCost(cell) {
  const base = 50;
  const lvl  = cell.upgrade || 0;
  let cost = Math.floor(base * (1 + lvl * 0.5));

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}



function startInterWave() {
  interWave = true;
  waveStartLock = false;    // â†’ ë‹¤ìŒ ì›¨ì´ë¸Œ ë²„íŠ¼ ë‹¤ì‹œ ëˆ„ë¥¼ ìˆ˜ ìˆë„ë¡ í’€ì–´ ì¤Œ
  ATP += (100 + wave * 50);

  // íƒ€ì´ë¨¸ ì´ˆê¸°í™”â€¦
  const duration = 30 * 1000;
  const startTs  = Date.now();
  timerDisplay.textContent = `Upgrade Time: ${Math.ceil(duration/1000)}s`;
  updateUIButtons();

  interTimer = setInterval(() => {
    // (ìƒëµ)
    if (elapsed >= duration) {
      clearInterval(interTimer);
      interTimer = null;
      startBtn.click();  // ìë™ ì‹œì‘
    }
  }, 200);
}



function showWaveBanner(txt) {
  waveBanner.textContent = txt;
  waveBanner.style.opacity = 1;
  setTimeout(() => waveBanner.style.opacity = 0, 2000);
}

function drawHealthBar(x,y,w,h,hp,mh) { ctx.fillStyle='black';ctx.fillRect(x,y,w,h);ctx.fillStyle='lime';ctx.fillRect(x,y,w*(hp/mh),h);ctx.strokeStyle='white';ctx.strokeRect(x,y,w,h); }
function drawEnemyStats(e) { ctx.fillStyle='white';ctx.font='12px Arial';ctx.fillText(`HP:${Math.round(e.hp)}`,e.x-15,e.y-e.size-18);ctx.fillText(`DMG:${e.damageToCell}`,e.x-15,e.y-e.size-6); }
function drawElectricArc(x, y, ts, isBlue) {
  ctx.strokeStyle = isBlue ? '#00f6ff' : 'yellow';
  ctx.lineWidth=3;
  ts.forEach(t=>{
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(t.x,t.y); ctx.stroke();
  });
}
function drawCellImage(cell) {
  if (cell.type === 'plant') {
    ctx.drawImage(imgPlant, cell.x - 20, cell.y - 30, 40, 60);
  } else if (cell.type === 'basic') {
    ctx.drawImage(imgCell, cell.x - 20, cell.y - 20, 40, 40);
  } else if (cell.type === 'neuron') {
    ctx.drawImage(imgNeuron, cell.x - 20, cell.y - 20, 40, 40);
  }
}

function loop() {
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,800,600);
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth   = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();


  if (selectedCell) {
   ctx.save();
   ctx.globalAlpha = 0.4;
   const px = mouseX, py = mouseY;
   // ê¸°ë¬¼ ì´ë¯¸ì§€
   drawCellImage({ type: selectedCell, x: px, y: py });
   // ì‚¬ê±°ë¦¬ ì›
   const range = baseCellTypes[selectedCell].range || 0;
   if (range) {
     ctx.strokeStyle = 'white';
     ctx.beginPath();
     ctx.arc(px, py, range, 0, Math.PI * 2);
     ctx.stroke();
   }
   // ë ˆë²¨ í‘œì‹œ (ì´ˆê¸° Lv.0)
   ctx.fillStyle = '#4a8';
   ctx.font = 'bold 12px Arial';
   ctx.textAlign = 'center';
   ctx.fillText('Lv.0', px, py - 16);
   ctx.restore();
 }


  // 1) ë¼ì¸(ê°€ì´ë“œì„ ) í‘œì‹œ
  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();

  // 2) ì„¸í¬ ê·¸ë¦¬ê¸°
  cells.forEach(cell => {
    drawCellImage(cell);

    // ì´ë¦„
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(getCellDisplayName(cell), cell.x, cell.y - 30);

    // ë ˆë²¨
    ctx.fillStyle = '#4a8';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`Lv.${cell.upgrade}`, cell.x, cell.y - 16);

    // ì‹ë¬¼ ì„¸í¬ HP ë°”
    if (cell.type === 'plant') {
      drawHealthBar(cell.x - 20, cell.y + 35, 40, 6, cell.hp, cell.maxHp);
    }

    // ì„ íƒ ê°•ì¡°
    if (cell === selectedUpgradeTarget) {
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      if (cell.type === 'plant') {
        ctx.strokeRect(cell.x - 24, cell.y - 34, 48, 68);
      } else {
        ctx.beginPath();
        ctx.arc(cell.x, cell.y, 26, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();

    // â‘¡ ê³µê²© ë²”ìœ„ í‘œì‹œ: cell.range ë§Œí¼ í°ìƒ‰ ì ì„  ì›
    if (cell.range) {
      ctx.save();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, cell.range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }
  });

  // ...ì´í•˜ ê¸°ì¡´ loop ì½”ë“œ...

  // ì„¸í¬ ê³µê²©
  cells.forEach(cell=>{
    if(cell.type==='plant') return;
    if(cell.cooldown>0){ cell.cooldown--; return; }
    const type = baseCellTypes[cell.type];
if(cell.type==='basic'){
  let target=null, minD=Infinity;
  enemies.forEach(e=>{
    const d=Math.hypot(e.x-cell.x,e.y-cell.y);
    if(d<=cell.range && d<minD){ minD=d; target=e; }
  });
  if(target){
    // 5ë ˆë²¨ ì´ìƒì´ë©´ ì¿¨íƒ€ì„ ê°ì†Œ
    cell.cooldown = cell.upgrade >= 5 ? 30 : type.cooldownMax;
    projectiles.push({
      x:cell.x, y:cell.y, target, damage:cell.damage, speed:type.projectileSpeed,
      isWhiteBlood: cell.upgrade >= 5 // ë°±í˜ˆêµ¬í™” ì—¬ë¶€
    });
  }
    } else if(cell.type==='neuron'){
} else if (cell.type === 'neuron') {
  const hits = enemies.filter(e => Math.hypot(e.x-cell.x, e.y-cell.y) <= cell.range);
  if (hits.length) {
    hits.forEach(e => {
      e.hp -= cell.damage;
      // ìŠ¤í„´ ì¡°ê±´ ë¶„ê¸°
      if (!mapConfig.gimmick?.neuronStunResistance && cell.upgrade >= 5) {
        e.stun = 10;
      }
    });
    cell.arcTargets=hits; cell.cooldown=type.cooldownMax;
    cell.isBlueArc = cell.upgrade >= 5;
  }
}
  });

enemies.forEach(e => {
  // â”€â”€ 1) ì´ë™ ì†ë„ ì„¸íŒ… â”€â”€
  let moveSpeed = e.speed;
  if(e.stun && e.stun > 0) {
    moveSpeed = 0;
    e.stun--;
  }
  if(e.slow && e.slow > 0) {
    moveSpeed *= 0.5;
    e.slow--;
  }
  // â”€â”€ 2) ì¶©ëŒ ê²€ì‚¬ â”€â”€
  let didCollide = false;
  for (const cell of cells) {
    const dx = e.x - cell.x;
    const dy = e.y - cell.y;

    // (1) ì‹ë¬¼ ì„¸í¬ ì¶©ëŒ â†’ ë’¤ë¡œ íŠ•ê¸°ê¸°
    if (
      cell.type === 'plant' &&
      Math.abs(dx) <= cell.width/2 + e.size &&
      Math.abs(dy) <= cell.height/2 + e.size*0.6
    ) {
      // ì‹ë¬¼ì— ë°ë¯¸ì§€
      cell.hp -= e.damageToCell;

      if (cell.hp <= 0) {
        // 5ë ˆë²¨ ì´ìƒì´ë©´ ì£¼ë³€ ì  ìŠ¬ë¡œìš°
        const slowRadius = cell.range || 60;
        if (cell.hp <= 0 && cell.upgrade >= 5) {
          enemies.forEach(e2 => {
            if (Math.hypot(e2.x - cell.x, e2.y - cell.y) < slowRadius) {
              e2.slow = 60;
            }
          });
        }

        cells.splice(cells.indexOf(cell), 1);
      }
      didCollide = true;
      break; // ì¶©ëŒ ì‹œ forë¬¸ íƒˆì¶œ
    }
  }
  // â”€â”€ 3) ì¶©ëŒ ì—†ìœ¼ë©´ ì•ìœ¼ë¡œ ì´ë™ â”€â”€
  if (!didCollide) {
    e.x += moveSpeed;
  }

  // â”€â”€ 4) ë Œë”ë§ & ê°•ì¡° & HPë°” â”€â”€
  if (e.type === 'superVirus') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % superBacteriaFrames.length;
    }
    ctx.drawImage(
      superBacteriaFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
    } else if (e.type === 'virus') {
      // virus íƒ€ì… â†’ ì„¸ê·  ì´ë¯¸ì§€
      ctx.drawImage(
        imgVirusSprite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    } else if (e.type === 'parasite') {
      // parasite íƒ€ì… â†’ ê¸°ìƒì¶© ì´ë¯¸ì§€
      ctx.drawImage(
        imgParasite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    } else if (e.type === 'bacteria') {
      // bacteria íƒ€ì… â†’ ë°•í…Œë¦¬ì˜¤íŒŒì§€ ì´ë¯¸ì§€
      ctx.drawImage(
        imgBacteriophageSprite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
  }

  // ì„ íƒ ê°•ì¡°
  if (e === selectedEnemy) {
    ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth   = 3;
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, e.size + 4, e.size * 0.6 + 4, 0, 0, Math.PI * 2);
      ctx.stroke();
    ctx.restore();
  }

  drawHealthBar(e.x - e.size, e.y - e.size - 10, e.size*2, 6, e.hp, e.maxHp);
  drawEnemyStats(e);
}); 




  // íˆ¬ì‚¬ì²´
for(let i=projectiles.length-1;i>=0;i--){
  const p=projectiles[i];
  if(!p.target||p.target.hp<=0){ projectiles.splice(i,1); continue; }
  const dx=p.target.x-p.x, dy=p.target.y-p.y, d=Math.hypot(dx,dy);
  if(d<p.speed){
    p.target.hp-=p.damage;
    // ë°±í˜ˆêµ¬í™” ìŠ¬ë¡œìš° íš¨ê³¼
    if(p.isWhiteBlood && Math.random()<0.3) p.target.slow = 40;
    projectiles.splice(i,1);
  } else {
    p.x+=(dx/d)*p.speed; p.y+=(dy/d)*p.speed;
    ctx.fillStyle = p.isWhiteBlood ? '#fff' : 'white';
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
  }
}
  cells.forEach(cell=>{
    if(cell.type==='neuron'&&cell.arcTargets&&cell.cooldown>0)
      drawElectricArc(cell.x,cell.y,cell.arcTargets, cell.isBlueArc);
  });

  // ì  ì œê±°Â·ì²´ë ¥ ì†Œì§„
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.hp<=0){ enemies.splice(i,1); score+=10; ATP+=20;}
    else if (e.x > 800) {
      // ë‚¨ì€ HPì˜ 1% ë§Œí¼ ê¹ì•„ì¤€ë‹¤
      const dmg = e.hp * 0.01;
      health = Math.max(0, health - dmg);
      healthDisplay.textContent = health.toFixed(2);
      enemies.splice(i, 1);
      if (health <= 0) {
        showWaveBanner('ê²Œì„ ì¢…ë£Œ!');
        setTimeout(() => {
          const playerData = {
            score,
            username: localStorage.getItem('gdh_username'),
            realname: localStorage.getItem('gdh_realname')
          };
          location.href = 'hall.html?player=' + encodeURIComponent(JSON.stringify(playerData));
        });
        return;
      }
    }
  }

  if (!interWave && !waveInProgress && spawnDone && enemies.length === 0) {
    startInterWave();
  }

  loopId = requestAnimationFrame(loop);
}

interWave = true;
updateUIButtons();
waveDisplay.textContent = wave;
scoreDisplay.textContent = `Score: ${score}`;
loop();
  </script>
</body>
</html>