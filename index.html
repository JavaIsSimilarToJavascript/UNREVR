<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cell Defense - Ïõ®Ïù¥Î∏å Î™®Îìú</title>
  <style>
    body { margin: 0; background: #222; color: #eee; font-family: Arial; display: flex; flex-direction: column; align-items: center; }
    #gameCanvas {
      background: #111;
      border: 5px solid #0f0;
      display: block;
      margin-top: 20px;
      position: relative;
    }
    #ui {
      width: 800px;
      background: #333;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #0f0;
      color: #0f0;
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0 40px 0;
      flex-wrap: wrap;
      user-select: none;
    }
    #ui > div {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: bold;
      font-size: 18px;
    }
    #ui button {
      background: #0f0;
      color: #000;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    #ui button:hover {
      background: #0c0;
    }
    #ui button:disabled {
      background: #444;
      color: #999;
      cursor: default;
    }
    #waveBanner {
      position: absolute;
      top: 40px;
      font-size: 48px;
      color: #0f0;
      text-align: center;
      width: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div style="position: relative;">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <h1 id="waveBanner">Wave 1</h1>
  </div>
  <div id="ui">
    <div>ATP: <span id="atp">200</span></div>
    <div>Health: <span id="health">5</span></div>
    <div>Wave: <span id="wave">1</span></div>
    <button id="basicBtn">ÏùºÎ∞ò ÏÑ∏Ìè¨ (50 ATP)</button>
    <button id="neuronBtn">Îâ¥Îü∞ (80 ATP)</button>
    <button id="plantBtn">ÏãùÎ¨º ÏÑ∏Ìè¨ (60 ATP)</button>
    <button id="upgradeBtn">ÏÑ∏Ìè¨ ÏóÖÍ∑∏Î†àÏù¥Îìú (100 ATP)</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveBanner = document.getElementById('waveBanner');
    const atpDisplay = document.getElementById('atp');
    const healthDisplay = document.getElementById('health');
    const waveDisplay = document.getElementById('wave');
    const basicBtn = document.getElementById('basicBtn');
    const neuronBtn = document.getElementById('neuronBtn');
    const plantBtn = document.getElementById('plantBtn');
    const upgradeBtn = document.getElementById('upgradeBtn');

    let ATP = 200;
    let health = 5;
    let wave = 1;
    let waveInProgress = false;
    let enemiesToSpawn = 0;
    let enemiesSpawned = 0;
    let spawnInterval = null;
    let upgradeLevel = 0;

    const lines = [200, 400];
    const cells = [];
    const enemies = [];
    const projectiles = [];
    let selectedCell = null;

    const baseCellTypes = {
      basic: { damage: 5, range: 60, cooldownMax: 50, cost: 50, projectileSpeed: 8 },
      neuron: { damage: 3, range: 100, cooldownMax: 120, cost: 80 },
      plant: { hp: 150, cost: 60 }
    };

    const enemyTypes = [
      { hp: 30, speed: 1.0, color: '#d22', size: 20 },
      { hp: 45, speed: 0.7, color: '#720072', size: 30 },
      { hp: 35, speed: 0.9, color: '#ff6', size: 25 }
    ];

    function updateUIButtons() {
      basicBtn.disabled = ATP < 50;
      neuronBtn.disabled = ATP < 80;
      plantBtn.disabled = ATP < 60;
      upgradeBtn.disabled = ATP < 100;
    }

    function selectCell(type) {
      selectedCell = type;
      [basicBtn, neuronBtn, plantBtn].forEach(btn => btn.style.background = '#0f0');
      if (type === 'basic') basicBtn.style.background = '#0c0';
      if (type === 'neuron') neuronBtn.style.background = '#0c0';
      if (type === 'plant') plantBtn.style.background = '#0c0';
    }

    basicBtn.addEventListener('click', () => selectCell('basic'));
    neuronBtn.addEventListener('click', () => selectCell('neuron'));
    plantBtn.addEventListener('click', () => selectCell('plant'));
    upgradeBtn.addEventListener('click', () => {
      if (ATP < 100) return;
      ATP -= 100;
      upgradeLevel++;
      atpDisplay.textContent = ATP;
      applyUpgrades();
      updateUIButtons();
    });

    function applyUpgrades() {
      cells.forEach(cell => {
        if (cell.type === 'basic') {
          cell.damage = (cell.damage || baseCellTypes.basic.damage) + upgradeLevel * 2;
          cell.range = (cell.range || baseCellTypes.basic.range) + upgradeLevel * 10;
        } else if (cell.type === 'neuron') {
          cell.damage = (cell.damage || baseCellTypes.neuron.damage) + upgradeLevel;
          cell.range = (cell.range || baseCellTypes.neuron.range) + upgradeLevel * 8;
        } else if (cell.type === 'plant') {
          cell.hp += 30 * upgradeLevel;
        }
      });
    }

    function showWaveBanner(text) {
      waveBanner.textContent = text;
      waveBanner.style.opacity = 1;
      setTimeout(() => { waveBanner.style.opacity = 0; }, 2000);
    }

    function startWave() {
      waveInProgress = true;
      enemiesSpawned = 0;
      enemiesToSpawn = (wave === 5 || wave === 10) ? 1 : 5 + wave * 2;
      showWaveBanner(`Wave ${wave}`);
      spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave * 150, 500));
    }

    function spawnEnemy() {
      if (enemiesSpawned >= enemiesToSpawn) {
        clearInterval(spawnInterval);
        waveInProgress = false;
        return;
      }

      // Î≥¥Ïä§
      if ((wave === 5 || wave === 10) && enemiesSpawned === 0) {
        enemies.push({
          x: 0,
          y: 300,
          hp: (wave === 5 ? 800 : 2000),
          maxHp: (wave === 5 ? 800 : 2000),
          damageToCell: (wave === 5 ? 4 : 8),
          speed: 0.6,
          color: (wave === 5 ? 'orange' : 'red'),
          size: (wave === 5 ? 50 : 70),
          blocked: false,
          blockTimer: 0
        });
        enemiesSpawned++;
        clearInterval(spawnInterval);
        waveInProgress = false;
        return;
      }

      enemiesSpawned++;
      const base = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      const yLine = lines[Math.floor(Math.random() * lines.length)];

      enemies.push({
        x: 0,
        y: yLine,
        hp: base.hp + wave * 3,
        maxHp: base.hp + wave * 3,
        damageToCell: 1 + Math.floor(wave / 3),
        speed: base.speed + wave * 0.03,
        color: base.color,
        size: base.size,
        blocked: false,
        blockTimer: 0
      });
    }

    function checkWaveClear() {
      if (!waveInProgress && enemies.length === 0) {
        if (wave < 10) {
          wave++;
          waveDisplay.textContent = wave;
          startWave();
        } else {
          showWaveBanner('üéâ Î™®Îì† Ïõ®Ïù¥Î∏å ÌÅ¥Î¶¨Ïñ¥!');
        }
      }
    }

    setInterval(() => {
      ATP += Math.floor(cells.length * 3);
      atpDisplay.textContent = ATP;
      updateUIButtons();
    }, 1000);

    canvas.addEventListener('click', (e) => {
      if (!selectedCell) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      let cost = baseCellTypes[selectedCell].cost;
      if (ATP < cost) return;

      if (selectedCell === 'plant') {
        if (!lines.some(line => Math.abs(y - line) <= 20)) return;
      } else {
        if (lines.some(line => Math.abs(y - line) <= 20)) return;
      }

      let cell = { x, y, type: selectedCell, cooldown: 0, hp: baseCellTypes[selectedCell].hp };
      cell.damage = baseCellTypes[selectedCell].damage;
      cell.range = baseCellTypes[selectedCell].range;
      if (selectedCell === 'plant') {
        cell.width = 40;
        cell.height = 60;
      }

      cells.push(cell);
      ATP -= cost;
      atpDisplay.textContent = ATP;
      selectedCell = null;
      [basicBtn, neuronBtn, plantBtn].forEach(btn => btn.style.background = '#0f0');
      updateUIButtons();
    });

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 3;
      lines.forEach(y => {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(800, y);
        ctx.stroke();
      });

      cells.forEach(cell => {
        if (cell.type === 'plant') {
          ctx.fillStyle = baseCellTypes.plant.color;
          ctx.fillRect(cell.x - cell.width/2, cell.y - cell.height/2, cell.width, cell.height);
          ctx.strokeStyle = '#070';
          ctx.lineWidth = 3;
          ctx.strokeRect(cell.x - cell.width/2, cell.y - cell.height/2, cell.width, cell.height);
          drawHealthBar(cell.x - cell.width/2, cell.y - cell.height/2 - 10, cell.width, 6, cell.hp, baseCellTypes.plant.hp);
        } else {
          ctx.fillStyle = cell.type === 'basic' ? 'cyan' : 'yellow';
          ctx.beginPath();
          ctx.arc(cell.x, cell.y, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
          drawHealthBar(cell.x - 20, cell.y - 35, 40, 6, cell.hp, baseCellTypes[cell.type].hp);
        }
      });

      cells.forEach(cell => {
        if (cell.type === 'plant') return;
        if (cell.cooldown > 0) {
          cell.cooldown--;
          return;
        }
        if (cell.type === 'basic') {
          let target = null;
          let minDist = Infinity;
          enemies.forEach(e => {
            const dist = Math.hypot(e.x - cell.x, e.y - cell.y);
            if (dist <= cell.range && dist < minDist) {
              minDist = dist;
              target = e;
            }
          });
          if (target) {
            projectiles.push({ x: cell.x, y: cell.y, target, damage: cell.damage, speed: baseCellTypes.basic.projectileSpeed });
            cell.cooldown = baseCellTypes.basic.cooldownMax;
          }
        } else if (cell.type === 'neuron') {
          const targets = enemies.filter(e => Math.hypot(e.x - cell.x, e.y - cell.y) <= cell.range);
          if (targets.length > 0) {
            targets.forEach(t => t.hp -= cell.damage);
            cell.arcTargets = targets;
            cell.cooldown = baseCellTypes.neuron.cooldownMax;
          }
        }
      });

      enemies.forEach(e => {
        if (!e.blocked) e.speedCurrent = e.speed;
        else {
          e.blockTimer--;
          if (e.blockTimer <= 0) {
            e.blocked = false;
            e.speedCurrent = e.speed;
          }
        }
        let blockedNow = false;
        for (const cell of cells) {
          const dx = Math.abs(e.x - cell.x);
          const dy = Math.abs(e.y - cell.y);
          if (cell.type === 'plant') {
            if (dx <= (cell.width/2 + e.size) && dy <= (cell.height/2 + e.size*0.6)) {
              e.blocked = true;
              e.blockTimer = 30;
              e.speedCurrent = 0;
              cell.hp -= e.damageToCell;
              if (cell.hp <= 0) cells.splice(cells.indexOf(cell), 1);
              blockedNow = true;
            }
          } else {
            if (Math.hypot(dx, dy) < 25) {
              cell.hp -= e.damageToCell;
              if (cell.hp <= 0) cells.splice(cells.indexOf(cell), 1);
            }
          }
        }
        if (!blockedNow) e.x += e.speedCurrent || e.speed;
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.ellipse(e.x, e.y, e.size, e.size * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.stroke();
        drawHealthBar(e.x - e.size, e.y - e.size - 10, e.size * 2, 6, e.hp, e.maxHp);
      });

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); continue; }
        const dx = p.target.x - p.x;
        const dy = p.target.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < p.speed) {
          p.target.hp -= p.damage;
          projectiles.splice(i, 1);
        } else {
          p.x += (dx / dist) * p.speed;
          p.y += (dy / dist) * p.speed;
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      cells.forEach(cell => {
        if (cell.type === 'neuron' && cell.arcTargets && cell.cooldown > 0) {
          drawElectricArc(cell.x, cell.y, cell.arcTargets);
          if (cell.cooldown === 1) cell.arcTargets = null;
        }
      });

      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].hp <= 0) {
          enemies.splice(i, 1);
        } else if (enemies[i].x > 800) {
          health--;
          healthDisplay.textContent = health;
          enemies.splice(i, 1);
          if (health <= 0) {
            showWaveBanner('Í≤åÏûÑ Ï¢ÖÎ£å!');
          }
        }
      }
      checkWaveClear();
      requestAnimationFrame(loop);
    }

    function drawHealthBar(x, y, width, height, hp, maxHp) {
      ctx.fillStyle = 'black';
      ctx.fillRect(x, y, width, height);
      ctx.fillStyle = 'lime';
      ctx.fillRect(x, y, width * (hp / maxHp), height);
      ctx.strokeStyle = 'white';
      ctx.strokeRect(x, y, width, height);
    }

    function drawElectricArc(x, y, targets) {
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      targets.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();
      });
    }

    updateUIButtons();
    waveDisplay.textContent = wave;
    startWave();
    loop();
  </script>
</body>
</html>
