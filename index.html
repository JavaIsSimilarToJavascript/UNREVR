<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Cell Defense - 웨이브 모드</title>
  <style>
    /* Pixel Lab Theme for Game Screen */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    body {
      margin: 0;
      padding: 0;
      background-color: #2a2a2a;
      background-image:
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px);
      background-size: 32px 32px;
      font-family: 'Press Start 2P', monospace;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      margin-top: 20px;
      border: 8px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      image-rendering: pixelated;
    }
    #ui {
      width: 800px;
      background-color: #1a1a1a;
      border: 8px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      margin: 20px 0;
      padding: 16px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      box-sizing: border-box;
    }
    #ui > div {
      font-size: 12px;
      color: #eee;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ui button {
      background-color: #4a8;
      color: #000;
      border: 4px solid #030;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      image-rendering: pixelated;
    }
    #ui button:hover {
      background-color: #6af;
    }
    #ui button:disabled {
      background-color: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }
    #waveBanner {
      position: absolute;
      top: 20px;
      font-size: 32px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
      width: 100%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    #score, #highScore {
      font-size: 12px;
      color: #eee;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>ATP: <span id="atp">200</span></div>
    <div>체력: <span id="health">5</span></div>
    <div>웨이브: <span id="wave">1</span></div>
    <button id="basicBtn">기본세포(50)</button>
    <button id="neuronBtn">뉴런(80)</button>
    <button id="plantBtn">식물(60)</button>
    <button id="upgradeBtn">업그레이드(50)</button>
    <button id="startBtn">다음 웨이브</button>
    <span id="timer"></span>
    <span id="score">Score: 0</span>
    <span id="highScore">0</span>
  </div>
  <div style="position:relative;">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="waveBanner"></div>
  </div>
  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const waveBanner = document.getElementById('waveBanner');
const atpDisplay = document.getElementById('atp');
const healthDisplay = document.getElementById('health');
const waveDisplay = document.getElementById('wave');
const basicBtn = document.getElementById('basicBtn');
const neuronBtn = document.getElementById('neuronBtn');
const plantBtn = document.getElementById('plantBtn');
const upgradeBtn = document.getElementById('upgradeBtn');
const startBtn = document.getElementById('startBtn');
const timerDisplay = document.getElementById('timer');
const scoreDisplay = document.getElementById('score');
const highScoreDisplay = document.getElementById('highScore');

// 이미지 로드
const imgCell = new Image();
imgCell.src = 'images/cell.png';
const imgPlant = new Image();
imgPlant.src = 'images/plant.png';
const imgNeuron = new Image();
imgNeuron.src = 'images/new.png';

let ATP = 200;
let health = 5;
let wave = 1;
let enemiesToSpawn = 0;
let enemiesSpawned = 0;
let waveInProgress = false;
let interWave = true;
let interSeconds = 30;
let interTimer = null;
let spawnInterval = null;
let selectedCell = null;
let selectedUpgradeTarget = null;
let mouseX = 0, mouseY = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('gdh_highScore')) || 0;
highScoreDisplay.textContent = highScore;

const lines = [200, 400];
const cells = [];
const enemies = [];
const projectiles = [];

const baseCellTypes = {
  basic:  { damage:5, range:60, cooldownMax:50, cost:50, projectileSpeed:8 },
  neuron: { damage:3, range:100, cooldownMax:120, cost:80 },
  plant:  { hp:150, cost:60 }
};
const enemyTypes = [
  { hp:30, speed:1.0, color:'#d22', size:20 },
  { hp:45, speed:0.7, color:'#720072', size:30 },
  { hp:35, speed:0.9, color:'#ff6', size:25 }
];

function updateUIButtons() {
  basicBtn.disabled   = ATP < baseCellTypes.basic.cost  || !interWave;
  neuronBtn.disabled  = ATP < baseCellTypes.neuron.cost || !interWave;
  plantBtn.disabled   = ATP < baseCellTypes.plant.cost  || !interWave;
  upgradeBtn.disabled = !selectedUpgradeTarget || ATP < 50 || !interWave;
  startBtn.style.display = interWave ? 'inline-block' : 'none';
  timerDisplay.style.display = interWave ? 'inline-block' : 'none';
  atpDisplay.textContent = ATP;
  healthDisplay.textContent = health;
  waveDisplay.textContent = wave;
  scoreDisplay.textContent = `Score: ${score}`;
  highScoreDisplay.textContent = highScore;
}

basicBtn.onclick = () => selectCell('basic');
neuronBtn.onclick = () => selectCell('neuron');
plantBtn.onclick = () => selectCell('plant');
function selectCell(type) {
  selectedCell = type;
  selectedUpgradeTarget = null;
  [basicBtn, neuronBtn, plantBtn].forEach(b => b.style.background = '#0f0');
  document.getElementById(type+'Btn').style.background = '#0c0';
  updateUIButtons();
}

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
});
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  if (selectedCell && interWave) {
    const cost = baseCellTypes[selectedCell].cost;
    if (ATP < cost) return;
    if (selectedCell==='plant' && !lines.some(L=>Math.abs(y-L)<=20)) return;
    if (selectedCell!=='plant' && lines.some(L=>Math.abs(y-L)<=20)) return;
    const cell = { x,y,type:selectedCell,cooldown:0,hp:baseCellTypes[selectedCell].hp,damage:baseCellTypes[selectedCell].damage||0,range:baseCellTypes[selectedCell].range||0,upgrade:0 };
    if (selectedCell==='plant') { cell.width=40; cell.height=60; }
    cells.push(cell);
    ATP -= cost;
    selectedCell = null;
    [basicBtn, neuronBtn, plantBtn].forEach(b=>b.style.background='#0f0');
    updateUIButtons();
    return;
  }
  selectedUpgradeTarget = null;
  for (const c of cells) {
    const dx = x - c.x;
    const dy = y - c.y;
    const hit = (c.type==='plant') ? Math.abs(dx)<=20 && Math.abs(dy)<=30 : Math.hypot(dx,dy)<=20;
    if (hit) { selectedUpgradeTarget = c; break; }
  }
  updateUIButtons();
});

upgradeBtn.onclick = () => {
  if (!selectedUpgradeTarget || ATP < 50) return;
  ATP -= 50;
  const c = selectedUpgradeTarget;
  c.upgrade = (c.upgrade || 0) + 1;
  if (c.type==='basic') { c.damage += 2; c.range += 10; }
  else if (c.type==='neuron') { c.damage += 1.5; c.range += 8; }
  else { c.hp += 30; }
  updateUIButtons();
};

startBtn.onclick = () => {
  interWave = false;
  waveInProgress = true;
  updateUIButtons();
  spawnWave();
};

function spawnWave() {
  enemiesSpawned = 0;
  enemiesToSpawn = 5 + wave * 2;
  if (wave % 5 === 0 && wave > 1) enemiesToSpawn *= 2;
  ATP += 100; // reward at start of wave
  updateUIButtons();
  showWaveBanner(`Wave ${wave}`);
  spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
}

function spawnEnemy() {
  if (enemiesSpawned++ >= enemiesToSpawn) {
    clearInterval(spawnInterval);
    waveInProgress = false;
    startInterWave();
    return;
  }
  const base = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
  const y = lines[Math.floor(Math.random()*lines.length)];
  enemies.push({ x:0, y, hp:base.hp + wave*5, maxHp:base.hp + wave*5, damageToCell:1 + Math.floor(wave/3), speed:base.speed + wave*0.05, color:base.color, size:base.size, blocked:false, blockTimer:0 });
}

function startInterWave() {
  interWave = true;
  interSeconds = 30;
  timerDisplay.textContent = `Upgrade Time: ${interSeconds}s`;
  updateUIButtons();
  interTimer = setInterval(() => {
    interSeconds--;
    timerDisplay.textContent = `Upgrade Time: ${interSeconds}s`;
    if (interSeconds <= 0) {
      clearInterval(interTimer);
      wave++;
      updateUIButtons();
      startBtn.click();
    }
  }, 1000);
}

function showWaveBanner(txt) {
  waveBanner.textContent = txt;
  waveBanner.style.opacity = 1;
  setTimeout(() => waveBanner.style.opacity = 0, 2000);
}

function drawHealthBar(x,y,w,h,hp,mh) { ctx.fillStyle='black';ctx.fillRect(x,y,w,h);ctx.fillStyle='lime';ctx.fillRect(x,y,w*(hp/mh),h);ctx.strokeStyle='white';ctx.strokeRect(x,y,w,h); }
function drawEnemyStats(e) { ctx.fillStyle='white';ctx.font='12px Arial';ctx.fillText(`HP:${Math.round(e.hp)}`,e.x-15,e.y-e.size-18);ctx.fillText(`DMG:${e.damageToCell}`,e.x-15,e.y-e.size-6); }
function drawElectricArc(x,y,ts) { ctx.strokeStyle='yellow';ctx.lineWidth=3;ts.forEach(t=>{ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(t.x,t.y);ctx.stroke();}); }

function drawCellImage(cell) {
  if (cell.type === 'plant') {
    ctx.drawImage(imgPlant, cell.x - 20, cell.y - 30, 40, 60);
  } else if (cell.type === 'basic') {
    ctx.drawImage(imgCell, cell.x - 20, cell.y - 20, 40, 40);
  } else if (cell.type === 'neuron') {
    ctx.drawImage(imgNeuron, cell.x - 20, cell.y - 20, 40, 40);
  }
}

function loop() {
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,800,600);
  ctx.globalAlpha = 1;
  // 설치 프리뷰
  if (selectedCell && interWave) {
    ctx.save(); ctx.globalAlpha = 0.3;
    if (selectedCell === 'plant') {
      ctx.drawImage(imgPlant, mouseX - 20, mouseY - 30, 40, 60);
    } else if (selectedCell === 'basic') {
      ctx.drawImage(imgCell, mouseX - 20, mouseY - 20, 40, 40);
    } else if (selectedCell === 'neuron') {
      ctx.drawImage(imgNeuron, mouseX - 20, mouseY - 20, 40, 40);
    }
    ctx.restore();
    // 사거리 원
    const t = baseCellTypes[selectedCell];
    ctx.strokeStyle='white';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(mouseX,mouseY,t.range,0,Math.PI*2);ctx.stroke();
  }
    // 블럭 스타일 레인 그리기
    ctx.fillStyle = '#4a8';
    lines.forEach(y => {
      // 4px 두께의 네온 그린 밴드
      ctx.fillRect(0, y - 2, canvas.width, 4);
    });

  // 세포
  cells.forEach(cell=>{
    drawCellImage(cell);
    if (cell.upgrade>0) { ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText(`Lv.${cell.upgrade}`,cell.x-12,cell.y+30); }
    if (cell===selectedUpgradeTarget && interWave) {
      ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cell.x, cell.y, cell.range, 0, Math.PI*2); ctx.stroke();
      ctx.save(); ctx.strokeStyle='red'; ctx.lineWidth=3;
      if(cell.type==='plant') { ctx.strokeRect(cell.x-24, cell.y-34, 48, 68); }
      else { ctx.beginPath(); ctx.arc(cell.x, cell.y, 26, 0, Math.PI*2); ctx.stroke(); }
      ctx.restore();
    }
  });

  // 세포 공격
  cells.forEach(cell=>{
    if(cell.type==='plant') return;
    if(cell.cooldown>0){ cell.cooldown--; return; }
    const type = baseCellTypes[cell.type];
    if(cell.type==='basic'){
      let target=null, minD=Infinity;
      enemies.forEach(e=>{
        const d=Math.hypot(e.x-cell.x,e.y-cell.y);
        if(d<=cell.range && d<minD){ minD=d; target=e; }
      });
      if(target){
        projectiles.push({x:cell.x,y:cell.y,target,damage:cell.damage,speed:type.projectileSpeed});
        cell.cooldown = type.cooldownMax;
      }
    } else if(cell.type==='neuron'){
      const hits = enemies.filter(e=>Math.hypot(e.x-cell.x,e.y-cell.y)<=cell.range);
      if(hits.length){
        hits.forEach(e=>e.hp-=cell.damage);
        cell.arcTargets=hits; cell.cooldown=type.cooldownMax;
      }
    }
  });

  // 적 이동·충돌·렌더링
  enemies.forEach(e=>{
    if(!e.blocked) e.speedCurrent=e.speed;
    else{
      e.blockTimer--; if(e.blockTimer<=0){ e.blocked=false; e.speedCurrent=e.speed; }
    }
    let blockedNow=false;
    for(const cell of cells){
      const dx=Math.abs(e.x-cell.x), dy=Math.abs(e.y-cell.y);
      if(cell.type==='plant' && dx<=(cell.width/2+e.size) && dy<=(cell.height/2+e.size*0.6)){
        e.blocked=true; e.blockTimer=30; e.speedCurrent=0;
        cell.hp-=e.damageToCell;
        if(cell.hp<=0) cells.splice(cells.indexOf(cell),1);
        blockedNow=true;
      } else if(cell.type!=='plant' && Math.hypot(dx,dy)<25){
        cell.hp-=e.damageToCell;
        if(cell.hp<=0) cells.splice(cells.indexOf(cell),1);
      }
    }
    if(!blockedNow) e.x += e.speedCurrent||e.speed;
    ctx.fillStyle=e.color;
    ctx.beginPath(); ctx.ellipse(e.x,e.y,e.size,e.size*0.6,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='black'; ctx.stroke();
    drawHealthBar(e.x-e.size, e.y-e.size-10, e.size*2,6, e.hp, e.maxHp);
    drawEnemyStats(e);
  });

  // 투사체
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    if(!p.target||p.target.hp<=0){ projectiles.splice(i,1); continue; }
    const dx=p.target.x-p.x, dy=p.target.y-p.y, d=Math.hypot(dx,dy);
    if(d<p.speed){
      p.target.hp-=p.damage; projectiles.splice(i,1);
    } else {
      p.x+=(dx/d)*p.speed; p.y+=(dy/d)*p.speed;
      ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
    }
  }
  cells.forEach(cell=>{
    if(cell.type==='neuron'&&cell.arcTargets&&cell.cooldown>0) drawElectricArc(cell.x,cell.y,cell.arcTargets);
  });

  // 적 제거·체력 소진
  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){ enemies.splice(i,1); score+=10; }
    else if(enemies[i].x>800){
      health--; healthDisplay.textContent=health;
      enemies.splice(i,1);
      if(health<=0){ showWaveBanner('게임 종료!'); return; }
    }
  }

  updateUIButtons();
  loopId = requestAnimationFrame(loop);
}

interWave = true;
updateUIButtons();
waveDisplay.textContent = wave;
scoreDisplay.textContent = `Score: ${score}`;
loop();
  </script>
</body>
</html>