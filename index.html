<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Cell Defense - ë©”ì¸ ë©”ë‰´</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      font-family: 'Press Start 2P', monospace;
      color: #e0f7ea;
      background: radial-gradient(circle at center, #102010, #000);
      overflow: hidden;
      animation: bgAnim 30s infinite alternate;
    }

    @keyframes bgAnim {
      0%   { background-position: 0 0; }
      50%  { background-position: 100px 200px; }
      100% { background-position: 0 0; }
    }

    .container {
      width: 720px;
      padding: 40px;
      background: rgba(0, 0, 0, 0.75);
      border: 4px solid #3a6;
      box-shadow: 0 0 20px #3a6;
      text-align: center;
      margin: auto;
      margin-top: 60px;
      position: relative;
      z-index: 2;
    }

    .logo img {
      width: 140px; height: 140px;
      image-rendering: pixelated;
      border: 3px solid #3a6;
      box-shadow: 0 0 16px #3a6;
      animation: pulseGlow 2.5s infinite;
      margin-bottom: 16px;
    }

    @keyframes pulseGlow {
      0% { box-shadow: 0 0 6px #3a6; }
      50% { box-shadow: 0 0 20px #80ffb3; }
      100% { box-shadow: 0 0 6px #3a6; }
    }

    h1 {
      margin: 0 0 8px;
      font-size: 40px;
      color: #80ffb3;
      text-shadow: 0 0 6px #030, 0 0 12px #3a6;
    }

    .subtitle {
      font-size: 14px;
      color: #a0e8c0;
      margin-bottom: 24px;
    }

    .intro {
      font-size: 12px;
      margin-bottom: 30px;
      color: #b4ffd4;
      line-height: 1.8;
    }

    .menu {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-bottom: 28px;
    }

    .menu button {
      padding: 16px 0;
      font-size: 14px;
      background: #0f0f0f;
      color: #b4ffd4;
      border: 2px solid #3a6;
      cursor: pointer;
      transition: all 0.3s ease;
      image-rendering: pixelated;
      box-shadow: 0 0 4px #3a6;
    }

    .menu button:hover {
      background-color: #112;
      transform: scale(1.08);
      box-shadow: 0 0 12px #80ffb3;
    }

    .menu button span {
      display: inline-block;
      vertical-align: middle;
    }

    audio {
      display: none;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <!-- ë°°ê²½ ì• ë‹ˆë©”ì´ì…˜ ìº”ë²„ìŠ¤ -->
  <canvas id="bgCanvas"></canvas>

  <div class="container">
    <div class="logo">
      <img src="images/Unrevr.png" alt="UNREVR ë¡œê³ ">
    </div>
    <h1>Cell Defense</h1>
    <div class="subtitle">ì„¸í¬ ì§„í™” ìƒì¡´ ë””íœìŠ¤ ê²Œì„</div>
    <div class="intro">
      ì¹¨ì…í•˜ëŠ” ë°”ì´ëŸ¬ìŠ¤ ë¬´ë¦¬ë¡œë¶€í„° <br>
      ì„¸í¬ë¥¼ ì§€íœ˜í•˜ê³ , ë§ˆì§€ë§‰ í¬ë§ì´ ë˜ì–´ë³´ì„¸ìš”.
    </div>

    <div class="menu">
      <button onclick="location.href='main.html'"><span>â–¶ ê²Œì„ ì‹œì‘</span></button>
      <button onclick="location.href='roles.html'"><span>ğŸ“– ì—­í•  ì†Œê°œ</span></button>
      <button onclick="location.href='dex.html'"><span>ğŸ“… ì—°êµ¬ ë…¸íŠ¸</span></button>
    </div>
  </div>
  
  <!-- ë°”ì´ëŸ¬ìŠ¤ ë°°ê²½ íš¨ê³¼ -->
  <script>
    const canvas = document.getElementById("bgCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

<<<<<<< HEAD
  // 2) ì  í´ë¦­ ì‹œ
  if (selectedEnemy) {
    const e    = selectedEnemy;
    const name = enemyNames[e.type];
    const desc = enemyDescriptions[e.type];
    let html = `
      <div><strong>ì  â–¶ ${name}</strong></div>
      <div class="description">${desc}</div>
      <div>ì²´ë ¥: ${Math.round(e.hp)} / ${e.maxHp}</div>
      <div>ì†ë„: ${e.speed.toFixed(2)}</div>
      <div>ê³µê²©ë ¥: ${e.damageToCell}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 3) ì—…ê·¸ë ˆì´ë“œ ëŒ€ìƒ í´ë¦­ ì‹œ (ê¸°ì¡´ ë¡œì§)
  if (!selectedUpgradeTarget) {
    info.innerHTML = '';
    return;
  }
  const c    = selectedUpgradeTarget;
const type = c.type;
const names= { basic:'ê¸°ë³¸ ì„¸í¬', neuron:'ë‰´ëŸ°', plant:'ì‹ë¬¼ ì„¸í¬' };
const evolveNames = { basic:'ë°±í˜ˆêµ¬', neuron:'ì‹œëƒ…ìŠ¤ ë‰´ëŸ°', plant:'ì ì•¡ ì„¸í¬ë²½' };
const evolveDescs = {
  basic: 'ë°±í˜ˆêµ¬: ê³µê²©ì†ë„ ì¦ê°€, íˆ¬ì‚¬ì²´ê°€ í°ìƒ‰, ì ì„ 30% í™•ë¥ ë¡œ ë‘”í™”ì‹œí‚´',
  neuron: 'ì‹œëƒ…ìŠ¤ ë‰´ëŸ°: ì „ê²© ì´í™íŠ¸ê°€ íŒŒë€ìƒ‰, ì ì„ ê°ì „(ìŠ¤í„´)ì‹œí‚´',
  plant: 'ì ì•¡ ì„¸í¬ë²½: íŒŒê´´ ì‹œ ì£¼ë³€ ì  ë‘”í™”'
};
const curr = { damage:c.damage||0, range:c.range||0, hp:c.maxHp||0 };
const next = { ...curr };
if (type==='basic')     { next.damage+=2;  next.range+=10; }
else if (type==='neuron'){ next.damage+=1.5;next.range+=8; }
else /* plant */        { next.hp+=30; }
const cost = getUpgradeCost(c);

// ì§„í™” ë²„íŠ¼
  if (c.upgrade === 5) {
    // ì§„í™” ë¹„ìš© ê³„ì‚°
    const evoCost = getEvolutionCost(c);
    info.innerHTML = `
      <div><strong>ì§„í™” â–¶ ${evolveNames[type]}</strong></div>
      <div class="description">${evolveDescs[type]}</div>
      <div>ì§„í™” ë¹„ìš©: ${evoCost} ATP</div>
      <button id="evolveBtn" ${ATP < evoCost ? 'disabled' : ''}>ì§„í™”! (${evoCost})</button>
    `;
  } else {
  // ì—…ê·¸ë ˆì´ë“œ ë²„íŠ¼
  info.innerHTML = `
    <div><strong>ì¢…ë¥˜: ${c.upgrade >= 6 ? evolveNames[type] : names[type]}</strong></div>
    <div class="description">${c.upgrade >= 6 ? evolveDescs[type] : cellDescriptions[type]}</div>
    <div>ê³µê²©ë ¥: ${curr.damage} â†’ ${next.damage}</div>
    <div>ì‚¬ê±°ë¦¬: ${curr.range} â†’ ${next.range}</div>
    ${type==='plant'?`<div>ì²´ë ¥: ${curr.hp.toFixed(2)} â†’ ${next.hp.toFixed(2)}</div>`:``}
    <button id="infoUpgradeBtn" ${ATP<cost||c.upgrade>=6?'disabled':''}>ì—…ê·¸ë ˆì´ë“œ (${cost})</button>
  `;
}
   const sellRefund = Math.floor(c.spent / 2);
   info.innerHTML += `
     <button id="sellBtn">íŒë§¤ (í™˜ë¶ˆ ${sellRefund} ATP)</button>
   `;
}

function spawnWave() {
  spawnDone = false;
  enemiesSpawned = 0;
  // 5ì˜ ë°°ìˆ˜ ì›¨ì´ë¸Œë©´ ë³´ìŠ¤ 1ë§ˆë¦¬ + ì¼ë°˜ ì  (ë³´ìŠ¤ í¬í•¨ ì´ n+1ë§ˆë¦¬)
  if (wave % 5 === 0) {
    enemiesToSpawn = 5 + wave * 2; // ì¼ë°˜ ì  ìˆ˜
    enemiesToSpawn += 1;           // ë³´ìŠ¤ 1ë§ˆë¦¬ ì¶”ê°€
  } else {
    enemiesToSpawn = 5 + wave * 2;
  }
  updateUIButtons();

  // --- ì¤‘ê°„ë³´ìŠ¤ ê²½ê³  ë° ì„¸í¬ ì œê±° (10ì›¨ì´ë¸Œ) ---
  if (wave === 10) {
    showWaveBanner('ì¤‘ê°„ë³´ìŠ¤ ë“±ì¥!');
    // 1ì´ˆ í›„ ì¤‘ê°„ë³´ìŠ¤ ë“±ì¥(ì—°ì¶œ)
    setTimeout(() => {
      // ì„¸í¬ 3ê°œ ëœë¤ ì œê±° (ì´í™íŠ¸ ì ìš©)
      if (cells.length > 0) {
        const shuffled = cells.slice().sort(() => Math.random() - 0.5);
        for (let i = 0; i < Math.min(3, shuffled.length); i++) {
          const cell = shuffled[i];
          cell.disappearEffect = 30; // 30í”„ë ˆì„(0.5ì´ˆ) ì´í™íŠ¸
        }
        updateCellCount();
        updateCellInfo();
      }
      // ì‹¤ì œ ì  ìŠ¤í° ì‹œì‘
      spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
    }, 1000);
    return; // ì•„ë˜ spawnIntervalì€ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
  }

  showWaveBanner(`Wave ${wave}`);
  spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
}

function spawnEnemy() {
  if (enemiesSpawned >= enemiesToSpawn) {
    clearInterval(spawnInterval);
    waveInProgress = false;
    spawnDone = true;
    return;
  }
  // 5ì˜ ë°°ìˆ˜ ì›¨ì´ë¸Œ, ë§ˆì§€ë§‰ ì ì´ë©´ ë³´ìŠ¤ ë“±ì¥
  if (wave % 5 === 0 && enemiesSpawned === enemiesToSpawn - 1) {
    const y = lines[Math.floor(Math.random() * lines.length)];
    // 10ì›¨ì´ë¸Œ, 15ì›¨ì´ë¸Œ, ê·¸ ì™¸ ë³´ìŠ¤ íƒ€ì… ë¶„ê¸°
    let bossType = 'superVirus';
    let bossHp = 200 + wave * 20;
    let bossDmg = 3 + Math.floor(wave/5);
    if (wave === 10) {
      bossType = 'covidVirus';
      bossHp = 850; // ì¤‘ê°„ë³´ìŠ¤ ì²´ë ¥ ê°•í™”
      bossDmg = 10;  // ì¤‘ê°„ë³´ìŠ¤ ê³µê²©ë ¥ ê°•í™”
    } else if (wave === 15) {
      bossType = 'cancerCell';
      bossHp = 1000; // 15ì›¨ì´ë¸Œ ë³´ìŠ¤ ì²´ë ¥(ì ì ˆíˆ ì¡°ì •)
      bossDmg = 15;  // 15ì›¨ì´ë¸Œ ë³´ìŠ¤ ê³µê²©ë ¥(ì ì ˆíˆ ì¡°ì •)
    }
    const enemy = {
      type: bossType,
      x:0, y,
      hp: bossHp,
      maxHp: bossHp,
      speed: 0.8,
      color: '#ff0',
      size: 50,
      damageToCell: bossDmg,
      blocked: false, blockTimer: 0,
      animFrame: 0,
      animTick: 0
    };
    if (mapConfig.gimmick?.enemySpeedMultiplier) {
      enemy.speed *= mapConfig.gimmick.enemySpeedMultiplier;
    }
    enemies.push(enemy);

  } else {
    const base = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
    const y = lines[Math.floor(Math.random()*lines.length)];
    // wave 6ë¶€í„° ì²´ë ¥ ë³´ë„ˆìŠ¤ ì ìš©
    let hpBonus = 0;
    if (wave >= 6) {
      hpBonus = (wave - 5) * 7; // 6ì›¨ì´ë¸Œë¶€í„° ì›¨ì´ë¸Œë§ˆë‹¤ +7ì”© ì¶”ê°€
    }
    enemies.push({
      type: base.type,
      x:0, y,
      hp: base.hp + wave*5 + hpBonus,
      maxHp: base.hp + wave*5 + hpBonus,
      speed: base.speed + wave*0.05,
      color: base.color,
      size: base.size,
      damageToCell: 1 + Math.floor(wave/3),
      blocked: false, blockTimer: 0
    });
  }
  enemiesSpawned++;
}


// ì„¤ì¹˜ ë¹„ìš©: ê°™ì€ íƒ€ì… ì„¸í¬ ê°œìˆ˜ì— ë¹„ë¡€í•´ +10%ì”© ìƒìŠ¹
function getPlacementCost(type) {
  const base = baseCellTypes[type].cost;
  const count = cells.filter(c => c.type === type).length;
  let cost = Math.max(Math.floor(base * (1 + count * 0.1)), base);

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}


// ì—…ê·¸ë ˆì´ë“œ ë¹„ìš©: ë ˆë²¨ì— ë¹„ë¡€í•´ +50%ì”© ìƒìŠ¹
function getUpgradeCost(cell) {
  const base = 50;
  const lvl  = cell.upgrade || 0;
  let cost = Math.floor(base * (1 + lvl * 0.5));

  if (mapConfig.gimmick?.upgradeDiscount) {
    cost = Math.floor(cost * mapConfig.gimmick.upgradeDiscount);
  }

  return cost;
}



function startInterWave() {
  interWave = true;
  waveStartLock = false;
  ATP += (100 + wave * 50);

  // ì›¨ì´ë¸Œ 15ê°€ ëë‚˜ë©´ ê²Œì„ ì¢…ë£Œ
  if (wave >= 15) {
    showWaveBanner(`ëª¨ë“  ì›¨ì´ë¸Œ í´ë¦¬ì–´!\nìµœì¢… ì ìˆ˜: ${score}`);
    // ë²„íŠ¼ ë¹„í™œì„±í™”
    startBtn.style.display = 'none';
    timerDisplay.style.display = 'none';
    // 5ì´ˆ ë’¤ main.htmlë¡œ ì´ë™
    setTimeout(() => {
      window.location.href = 'main.html';
    }, 5000);
    return;
  }

  // Upgrade Time UI ì œê±°
  timerDisplay.textContent = '';
  updateUIButtons();

  // ì›¨ì´ë¸Œ ìë™ ì‹œì‘ íƒ€ì´ë¨¸ ì œê±°
  // ê¸°ì¡´ interTimer, setInterval ë“± ëª¨ë‘ ìƒëµ
  // ì‚¬ìš©ìê°€ startBtnì„ ëˆŒëŸ¬ì•¼ ë‹¤ìŒ ì›¨ì´ë¸Œê°€ ì‹œì‘ë¨
}



function showWaveBanner(txt) {
  waveBanner.textContent = txt;
  waveBanner.style.opacity = 1;
  setTimeout(() => waveBanner.style.opacity = 0, 2000);
}

function drawHealthBar(x,y,w,h,hp,mh) { ctx.fillStyle='black';ctx.fillRect(x,y,w,h);ctx.fillStyle='lime';ctx.fillRect(x,y,w*(hp/mh),h);ctx.strokeStyle='white';ctx.strokeRect(x,y,w,h); }
function drawEnemyStats(e) { ctx.fillStyle='white';ctx.font='12px Arial';ctx.fillText(`DMG:${e.damageToCell}`,e.x-15,e.y-e.size-6); }
function drawElectricArc(x, y, ts, isBlue) {
  ctx.strokeStyle = isBlue ? '#00f6ff' : 'yellow';
  ctx.lineWidth=3;
  ts.forEach(t=>{
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(t.x,t.y); ctx.stroke();
  });
}
function drawCellImage(cell) {
  ctx.save();
  if (cell.disappearEffect) {
    ctx.globalAlpha = cell.disappearEffect / 30;
  }
  // ì§„í™” ì´ë¯¸ì§€ ë¶„ê¸°
  if (cell.type === 'plant') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgPlantEvo, cell.x - 20, cell.y - 30, 40, 60);
    } else {
      ctx.drawImage(imgPlant, cell.x - 20, cell.y - 30, 40, 60);
    }
  } else if (cell.type === 'basic') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgCellEvo, cell.x - 20, cell.y - 20, 40, 40);
    } else {
      ctx.drawImage(imgCell, cell.x - 20, cell.y - 20, 40, 40);
    }
  } else if (cell.type === 'neuron') {
    if (cell.upgrade >= 6) {
      ctx.drawImage(imgNeuronEvo, cell.x - 20, cell.y - 20, 40, 40);
    } else {
      ctx.drawImage(imgNeuron, cell.x - 20, cell.y - 20, 40, 40);
    }
  }
  ctx.restore();
}

// ì´ë¯¸ì§€ ë¡œë“œ ë¶€ë¶„ì— ì§„í™” ì´ë¯¸ì§€ ì¶”ê°€
const imgCellEvo = new Image();
imgCellEvo.src = 'images/Cellevo.png';
const imgPlantEvo = new Image();
imgPlantEvo.src = 'images/plantevo.png';
const imgNeuronEvo = new Image();
imgNeuronEvo.src = 'images/newevo.png';

function loop() {
  // disappearEffect ì²˜ë¦¬ ë° ì„¸í¬ ì œê±° (ì´í™íŠ¸ ëë‚œ ì„¸í¬ë§Œ)
  for (let i = cells.length - 1; i >= 0; i--) {
    const cell = cells[i];
    if (cell.disappearEffect) {
      cell.disappearEffect--;
      if (cell.disappearEffect <= 0) {
        cells.splice(i, 1);
        continue;
      }
    }
  }

  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,800,600);
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth   = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();

  if (selectedCell) {
   ctx.save();
   ctx.globalAlpha = 0.4;
   const px = mouseX, py = mouseY;
   // ê¸°ë¬¼ ì´ë¯¸ì§€
   drawCellImage({ type: selectedCell, x: px, y: py });
   // ì‚¬ê±°ë¦¬ ì›
   const range = baseCellTypes[selectedCell].range || 0;
   if (range) {
     ctx.strokeStyle = 'white';
     ctx.beginPath();
     ctx.arc(px, py, range, 0, Math.PI * 2);
     ctx.stroke();
   }
   // ë ˆë²¨ í‘œì‹œ (ì´ˆê¸° Lv.0)
   ctx.fillStyle = '#4a8';
   ctx.font = 'bold 12px Arial';
   ctx.textAlign = 'center';
   ctx.fillText('Lv.0', px, py - 16);
   ctx.restore();
 }

  // 1) ë¼ì¸(ê°€ì´ë“œì„ ) í‘œì‹œ
  ctx.save();
  ctx.strokeStyle = '#4a8';
  ctx.lineWidth = 2;
  lines.forEach(y => {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  });
  ctx.restore();

  // 2) ì„¸í¬ ê·¸ë¦¬ê¸°
  cells.forEach(cell => {
    drawCellImage(cell);

    // ì´ë¦„
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(getCellDisplayName(cell), cell.x, cell.y - 30);

    // ë ˆë²¨
    ctx.fillStyle = '#4a8';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`Lv.${cell.upgrade}`, cell.x, cell.y - 16);

    // ì‹ë¬¼ ì„¸í¬ HP ë°” (ì†Œìˆ˜ì  ë‘˜ì§¸ìë¦¬ê¹Œì§€)
    if (cell.type === 'plant') {
      drawHealthBar(cell.x - 20, cell.y + 35, 40, 6, cell.hp, cell.maxHp);
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${cell.hp.toFixed(2)} / ${cell.maxHp.toFixed(2)}`, cell.x, cell.y + 48);
      ctx.restore();
=======
    const particles = [];
    for (let i = 0; i < 60; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        r: Math.random() * 2 + 1,
        dx: Math.random() * 0.8 - 0.4,
        dy: Math.random() * 0.8 - 0.4,
      });
>>>>>>> 9e54dea200a83b13e6fa98116082c45eaa5250a6
    }

    function drawParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgba(58, 160, 120, 0.3)";
      for (let p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
        p.x += p.dx;
        p.y += p.dy;

        if (p.x < 0 || p.x > canvas.width) p.dx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.dy *= -1;
      }
      requestAnimationFrame(drawParticles);
    }

    drawParticles();

<<<<<<< HEAD
enemies.forEach(e => {
  // â”€â”€ 1) ì´ë™ ì†ë„ ì„¸íŒ… â”€â”€
  let moveSpeed = e.speed;
  if(e.stun && e.stun > 0) {
    moveSpeed = 0;
    e.stun--;
  }
  if(e.slow && e.slow > 0) {
    moveSpeed *= 0.5;
    e.slow--;
  }
  // â”€â”€ 2) ì¶©ëŒ ê²€ì‚¬ â”€â”€
  let didCollide = false;
  for (const cell of cells) {
    const dx = e.x - cell.x;
    const dy = e.y - cell.y;

    // (1) ì‹ë¬¼ ì„¸í¬ ì¶©ëŒ â†’ ë’¤ë¡œ íŠ•ê¸°ê¸°
    if (
      cell.type === 'plant' &&
      Math.abs(dx) <= 20 + e.size &&   // â† ì„¸í¬ë²½(ì‹ë¬¼) ê°€ë¡œ ë°˜í­ 20
      Math.abs(dy) <= 30 + e.size * 0.6 // â† ì„¸í¬ë²½(ì‹ë¬¼) ì„¸ë¡œ ë°˜ë†’ì´ 30
    ) {
      // ì‹ë¬¼ì— ë°ë¯¸ì§€
      cell.hp -= e.damageToCell;

      if (cell.hp <= 0) {
        // 5ë ˆë²¨ ì´ìƒì´ë©´ ì£¼ë³€ ì  ìŠ¬ë¡œìš°
        const slowRadius = cell.range || 60;
        if (cell.upgrade >= 6) {
          enemies.forEach(e2 => {
            if (Math.hypot(e2.x - cell.x, e2.y - cell.y) < slowRadius) {
              e2.slow = 60;
            }
          });
        }
        // ì£½ì€ ì‹ë¬¼ ì„¸í¬ëŠ” ì¦‰ì‹œ ë°°ì—´ì—ì„œ ì œê±° (ì´í™íŠ¸ëŠ” ë³„ë„ ì²˜ë¦¬)
        const idx = cells.indexOf(cell);
        if (idx !== -1) {
          cell.disappearEffect = 30; // ì£½ì€ ì„¸í¬ íš¨ê³¼
          cells.splice(idx, 1);
        }
        updateCellCount();
        updateCellInfo();
        break;
      }
      // ì ì„ ë’¤ë¡œ ë°€ê¸° (ë§‰í˜ íš¨ê³¼)
      e.x -= moveSpeed; // â† ì´ë™ì„ ì·¨ì†Œ(í˜¹ì€ ë” ê°•í•˜ê²Œ ë°€ê³  ì‹¶ìœ¼ë©´ *2 ë“±)
      didCollide = true;
      break; // ì¶©ëŒ ì‹œ forë¬¸ íƒˆì¶œ
    }
  }
  // â”€â”€ 3) ì¶©ëŒ ì—†ìœ¼ë©´ ì•ìœ¼ë¡œ ì´ë™ â”€â”€
  if (!didCollide) {
    e.x += moveSpeed;
  }

  // â”€â”€ 4) ë Œë”ë§ & ê°•ì¡° & HPë°” â”€â”€
  if (e.type === 'superVirus') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % superBacteriaFrames.length;
    }
    ctx.drawImage(
      superBacteriaFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'covidVirus') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % covidFrames.length;
    }
    ctx.drawImage(
      covidFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'cancerCell') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % cancerFrames.length;
    }
    ctx.drawImage(
      cancerFrames[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'virus') {
    // virus íƒ€ì… â†’ ì„¸ê·  ì´ë¯¸ì§€
    ctx.drawImage(
      imgVirusSprite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'parasite') {
    // parasite íƒ€ì… â†’ ê¸°ìƒì¶© ì´ë¯¸ì§€
    ctx.drawImage(
      imgParasite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  } else if (e.type === 'bacteria') {
    // bacteria íƒ€ì… â†’ ë°•í…Œë¦¬ì˜¤íŒŒì§€ ì´ë¯¸ì§€
    ctx.drawImage(
      imgBacteriophageSprite,
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  }
  // 15ì›¨ì´ë¸Œ ë³´ìŠ¤ 2í˜ì´ì¦ˆ êµ¬í˜„
  else if (e.type === 'cancerCell2') {
    e.animTick = (e.animTick || 0) + 1;
    if (e.animTick % 8 === 0) {
      e.animFrame = ((e.animFrame || 0) + 1) % cancerFrames2.length;
    }
    ctx.drawImage(
      cancerFrames2[e.animFrame || 0],
      e.x - e.size, e.y - e.size,
      e.size * 2, e.size * 2
    );
  }

  // ì„ íƒ ê°•ì¡°
  if (e === selectedEnemy) {
    ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth   = 3;
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, e.size + 4, e.size * 0.6 + 4, 0, 0, Math.PI * 2);
      ctx.stroke();
    ctx.restore();
  }

  drawHealthBar(e.x - e.size, e.y - e.size - 10, e.size*2, 6, e.hp, e.maxHp);
  // ì²´ë ¥ ì†Œìˆ˜ì  ë‘˜ì§¸ìë¦¬ê¹Œì§€ í‘œì‹œ
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`${e.hp.toFixed(2)} / ${e.maxHp.toFixed(2)}`, e.x, e.y - e.size - 14);
  ctx.restore();
  drawEnemyStats(e);
}); 




  // íˆ¬ì‚¬ì²´
for(let i=projectiles.length-1;i>=0;i--){
  const p=projectiles[i];
  if(!p.target||p.target.hp<=0){ projectiles.splice(i,1); continue; }
  const dx=p.target.x-p.x, dy=p.target.y-p.y, d=Math.hypot(dx,dy);
  if(d<p.speed){
    p.target.hp-=p.damage;
    // ë°±í˜ˆêµ¬í™” ìŠ¬ë¡œìš° íš¨ê³¼
    if(p.isWhiteBlood && Math.random()<0.3) p.target.slow = 40;
    projectiles.splice(i,1);
  } else {
    p.x+=(dx/d)*p.speed; p.y+=(dy/d)*p.speed;
    ctx.fillStyle = p.isWhiteBlood ? '#FF0000' : 'red';
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
  }
}
  cells.forEach(cell=>{
    if(cell.type==='neuron'&&cell.arcTargets&&cell.cooldown>0)
      drawElectricArc(cell.x,cell.y,cell.arcTargets, cell.isBlueArc);
  });

  // ì  ì œê±°Â·ì²´ë ¥ ì†Œì§„
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.hp<=0){ 
      // 15ì›¨ì´ë¸Œ ë³´ìŠ¤ 2í˜ì´ì¦ˆ êµ¬í˜„
      if (e.type === 'cancerCell' && wave === 15 && !e.secondPhase) {
        // 2í˜ì´ì¦ˆ ë³´ìŠ¤ ì†Œí™˜
        showWaveBanner('ì•„ì§ ëì´ ì•„ë‹ˆë‹¤! ë” ê°•í•œ ì•”ì„¸í¬ ë“±ì¥!');
        const y = e.y;
        const boss2 = {
          type: 'cancerCell2',
          x: 0, y: y,
          hp: 1800,
          maxHp: 1800,
          speed: 1.2,
          color: '#f0f',
          size: 80,
          damageToCell: 20,
          blocked: false, blockTimer: 0,
          animFrame: 0,
          animTick: 0,
          secondPhase: true
        };
        enemies.push(boss2);
      }
      console.log('ì£½ì€ ì êµ° ì œê±°', e);
      enemies.splice(i,1); 
      score+=10; 
      ATP+=20;
      scoreDisplay.textContent = `Score: ${score}`;
      atpDisplay.textContent = ATP;
      continue; // ì£½ì€ ì ì€ ë” ì´ìƒ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
    }
    if (e.x > 800 && e.hp > 0) {
      console.log('ì‚´ì•„ìˆëŠ” ì êµ°ì´ ë ë„ë‹¬', e);
      const dmg = e.damageToCell * (e.hp / e.maxHp);
      health = Math.max(0, health - dmg);
      healthDisplay.textContent = health.toFixed(2);
      enemies.splice(i, 1);
      if (health <= 0) {
        if (reviveCount < 2) {
          let reviveCost = reviveCount === 0 ? 500 : 750;
          let reviveMsg = reviveCount === 0 ? 'ì½”ì¸ 500ê°œë¡œ ë¶€í™œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?' : 'ì½”ì¸ 750ê°œë¡œ ë¶€í™œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
          showWaveBanner('ê´€ë¦¬ì í‚¤ë¥¼ ì…ë ¥í•´ì•¼ ë¶€í™œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!');
          // ì…ë ¥ì°½ ë° ë²„íŠ¼ ìƒì„±
          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100vw';
          overlay.style.height = '100vh';
          overlay.style.background = 'rgba(0,0,0,0.7)';
          overlay.style.zIndex = 2000;
          overlay.style.display = 'flex';
          overlay.style.flexDirection = 'column';
          overlay.style.justifyContent = 'center';
          overlay.style.alignItems = 'center';

          const msg = document.createElement('div');
          msg.textContent = reviveMsg;
          msg.style.color = '#fff';
          msg.style.fontSize = '22px';
          msg.style.marginBottom = '18px';
          overlay.appendChild(msg);

          const input = document.createElement('input');
          input.type = 'password';
          input.placeholder = 'ê´€ë¦¬ì í‚¤ ì…ë ¥';
          input.style.fontSize = '20px';
          input.style.padding = '8px';
          input.style.marginBottom = '12px';
          overlay.appendChild(input);

          const reviveBtn = document.createElement('button');
          reviveBtn.textContent = 'ë¶€í™œí•˜ê¸°';
          reviveBtn.style.fontSize = '20px';
          reviveBtn.style.padding = '12px 32px';
          reviveBtn.style.background = '#ff0';
          reviveBtn.style.color = '#000';
          reviveBtn.style.border = '4px solid #4a8';
          reviveBtn.style.cursor = 'pointer';
          overlay.appendChild(reviveBtn);

          const errorMsg = document.createElement('div');
          errorMsg.style.color = '#ff4444';
          errorMsg.style.fontSize = '16px';
          errorMsg.style.marginTop = '10px';
          overlay.appendChild(errorMsg);

          // í¬ê¸°í•˜ê¸° ë²„íŠ¼ ì¶”ê°€
          const giveUpBtn = document.createElement('button');
          giveUpBtn.textContent = 'í¬ê¸°í•˜ê¸°';
          giveUpBtn.style.fontSize = '18px';
          giveUpBtn.style.padding = '10px 28px';
          giveUpBtn.style.background = '#888';
          giveUpBtn.style.color = '#fff';
          giveUpBtn.style.border = '2px solid #333';
          giveUpBtn.style.marginTop = '18px';
          giveUpBtn.style.cursor = 'pointer';
          overlay.appendChild(giveUpBtn);

          giveUpBtn.onclick = () => {
            overlay.innerHTML = `<div style='color:#fff;font-size:22px;margin-bottom:12px;'>Score: ${score}</div><div style='color:#ff0;font-size:20px;'>ë©”ì¸ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤...</div>`;
            setTimeout(() => {
              window.location.href = 'main.html';
            }, 2000);
          };

          document.body.appendChild(overlay);
          cancelAnimationFrame(loopId);

          reviveBtn.onclick = () => {
            if (input.value !== ADMIN_KEY) {
              errorMsg.textContent = 'ê´€ë¦¬ì í‚¤ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤!';
              return;
            }
            // ì½”ì¸ ì°¨ê° ì—†ì´ ë¶€í™œ
            reviveCount++;
            overlay.remove();
            health = 5;
            healthDisplay.textContent = health.toFixed(2);
            showWaveBanner('ìƒëª…ë ¥ì´ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤!');
            loopId = requestAnimationFrame(loop);
          };
          return;
        } else {
          showWaveBanner('ê²Œì„ ì¢…ë£Œ!');
          // ì ìˆ˜ í‘œì‹œ ë“± ì¶”ê°€ ì½”ë“œê°€ ìˆë‹¤ë©´ ì—¬ê¸°ì—
          return;
        }
      }
    }
    if (e.x > 800 && e.hp <= 0) {
      console.log('hp 0 ì´í•˜ì¸ë° ë ë„ë‹¬', e);
    }
  }

  if (!interWave && !waveInProgress && spawnDone && enemies.length === 0) {
    startInterWave();
  }

  loopId = requestAnimationFrame(loop);
}

interWave = true;
updateUIButtons();
waveDisplay.textContent = wave;
scoreDisplay.textContent = `Score: ${score}`;
loop();
=======
    
>>>>>>> 9e54dea200a83b13e6fa98116082c45eaa5250a6
  </script>
</body>
</html>
