<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Cell Defense - 웨이브 모드</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body {
      margin: 0;
      padding: 0;
      background-color: #2a2a2a;
      background-image:
        linear-gradient(rgba(58,58,58,0.8) 2px, transparent 2px),
        linear-gradient(90deg, rgba(58,58,58,0.8) 2px, transparent 2px);
      background-size: 32px 32px;
      font-family: 'Press Start 2P', monospace;
      color: #eee;
      display: flex;
      justify-content: center;
      padding-top: 20px;
    }

    .container {
      /* 캔버스(800) + 사이드바 양쪽(200×2) + 컬럼 간격(12×2) = 1224px
         여기에 padding(16×2) + border(8×2) 합 48px을 합쳐서 총 1272px */
      width: 1272px;
      box-sizing: border-box;
      padding: 16px;
      border: 8px solid #4a8;
      background-color: #1a1a1a;
      box-shadow: inset 0 0 0 4px #030;
    }

    .content-row {
      display: flex;
      gap: 12px;
    }

    .sidebar {
      width: 200px;           /* 160 → 200px로 넓힘 */
      box-sizing: border-box;
      padding: 12px;
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      font-size: 12px;
      line-height: 1.4;
    }
    .sidebar h2 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #4a8;
      text-shadow: 1px 1px 0 #030;
    }
    .sidebar ul, .sidebar ol {
      margin: 8px 0;
      padding-left: 16px;
    }
    .sidebar hr {
      border: none;
      border-top: 1px solid #4a8;
      margin: 8px 0;
    }

    .main {
      flex: 1;                /* 중앙에 남은 공간을 전부 할당 */
      display: flex;
      flex-direction: column;
      align-items: center;    /* 캔버스 등 중앙 정렬 */
    }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .header img {
      width: 64px;
      height: 64px;
      image-rendering: pixelated;
      border: 4px solid #4a8;
    }
    .header h1 {
      margin: 0;
      font-size: 28px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
    }

    #ui {
      width: 800px;           /* 캔버스 너비와 맞춰서 중앙 고정 */
      background-color: #0f0f0f;
      border: 4px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      margin-bottom: 20px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    #ui > div, #ui span {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ui button {
      background-color: #4a8;
      color: #000;
      border: 4px solid #030;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      image-rendering: pixelated;
    }
    #ui button:hover {
      background-color: #6af;
    }
    #ui button:disabled {
      background-color: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }

    .game-area {
      position: relative;
      width: 800px;           /* 캔버스 고정 폭 */
    }
    #gameCanvas {
      display: block;
      width: 800px;
      height: 600px;
      border: 8px solid #4a8;
      box-shadow: inset 0 0 0 4px #030;
      image-rendering: pixelated;
    }
    #waveBanner {
      position: absolute;
      top: 20px;
      width: 100%;
      font-size: 32px;
      color: #4a8;
      text-shadow: 2px 2px 0 #030;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    #cellInfo {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 200px;
      padding: 8px;
      background: rgba(17,17,17,0.9);
      border: 2px solid #4a8;
      font-size: 12px;
      line-height: 1.4;
      color: #eee;
      z-index: 10;
    }
    #cellInfo .description {
      font-size: 10px;
      color: #ccc;
      margin: 4px 0;
    }
    #cellInfo button {
      margin-top: 6px;
      background: #4a8;
      color: #000;
      border: 2px solid #030;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #cellInfo button:disabled {
      background: #333;
      color: #555;
      border-color: #555;
      cursor: default;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="content-row">

      <!-- 왼쪽 사이드바 -->
      <aside class="sidebar left">
        <h2>세포 가이드</h2>
        <ul>
          <li>기본 세포: 단일 타겟 집중 공격</li>
          <li>뉴런 세포: 범위 내 전격 공격</li>
          <li>식물 세포: 경로 차단·방어장 생성</li>
        </ul>
      </aside>

      <!-- 중앙 메인 영역 -->
      <main class="main">
        <div class="header">
          <img src="images/Unrevr.png" alt="UNREVR 로고">
          <h1>Cell Defense - 웨이브 모드</h1>
        </div>

        <div id="ui">
          <div>ATP: <span id="atp">200</span></div>
          <div>체력: <span id="health">5</span></div>
          <div>웨이브: <span id="wave">1</span></div>
          <div>세포 수: <span id="cellCount">0</span> / 20</div>
          <button id="basicBtn">기본세포(50)</button>
          <button id="neuronBtn">뉴런(80)</button>
          <button id="plantBtn">식물세포(60)</button>
          <button id="startBtn">다음 웨이브</button>
          <span id="timer"></span>
          <span id="score">Score: 0</span>
          <span id="highScore">HighScore: 0</span>
        </div>

        <div class="game-area">
          <canvas id="gameCanvas" width="800" height="600"></canvas>
          <div id="waveBanner"></div>
          <div id="cellInfo"></div>
        </div>
      </main>

      <!-- 오른쪽 사이드바 -->
      <aside class="sidebar right">
        <h2>웨이브 정보</h2>
        <div>현재 웨이브: <span id="wave">1</span></div>
        <div>다음 보스: 슈퍼 바이러스</div>
        <hr>
        <h2>리더보드</h2>
        <ol id="leaderboard">
          <li>플레이어1 – 1200</li>
          <li>플레이어2 – 950</li>
          <li>플레이어3 – 730</li>
        </ol>
      </aside>

    </div>
  </div>

  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const waveBanner = document.getElementById('waveBanner');
const atpDisplay = document.getElementById('atp');
const healthDisplay = document.getElementById('health');
const waveDisplay = document.getElementById('wave');
const basicBtn = document.getElementById('basicBtn');
const neuronBtn = document.getElementById('neuronBtn');
const plantBtn = document.getElementById('plantBtn');
const startBtn = document.getElementById('startBtn');
const timerDisplay = document.getElementById('timer');
const scoreDisplay = document.getElementById('score');
const highScoreDisplay = document.getElementById('highScore');
const MAX_CELLS = 20;

const imgCell = new Image();
imgCell.src = 'images/cell.png';
const imgPlant = new Image();
imgPlant.src = 'images/plant.png';
const imgNeuron = new Image();
imgNeuron.src = 'images/new.png';
const superBacteriaFrames = [];
const imgCellEvo = new Image();
imgCellEvo.src = 'images/Cellevo.png';
const imgNeuronEvo = new Image();
imgNeuronEvo.src = 'images/newevo.png';
const imgPlantEvo = new Image();
imgPlantEvo.src = 'images/plantevo.png';

const imgVirusSprite = new Image();
imgVirusSprite.src = 'images/세균.png';
const imgParasite = new Image();
imgParasite.src = 'images/기생충.png';
const imgBacteriophageSprite = new Image();
imgBacteriophageSprite.src = 'images/박테리오파지.png';

for (let i = 0; i <= 3; i++) {
  const img = new Image();
  img.src = `images/superbacteria${i}.png`;
  superBacteriaFrames.push(img);
}

const cellDescriptions = {
  basic:  '기본 세포(Animal Cell): 핵(nucleus), 미토콘드리아(mitochondria), 소포체(ER), 골지체(Golgi), 리소좀(lysosome) 등으로 이루어져 있으며, 단일 표적에 식균 작용(phagocytosis) 기반 공격을 합니다.',
  neuron: '뉴런(Neuron): 핵, 미토콘드리아, 소포체, 골지체 외에 시냅스 소포(synaptic vesicle)를 포함하며, 광역 전기 신호를 발사해 주변 모든 적에게 전격 공격을 가합니다.',
  plant:  '식물 세포(Plant Cell): 세포벽(cell wall), 엽록체(chloroplast), 중앙액포(vacuole), 미토콘드리아, 골지체 등으로 구성되어 있으며, 적의 이동을 차단하고 주변에 지속적인 방어장(Barrier)을 형성합니다.'
};

const enemyNames = {
  virus:      '바이러스',
  parasite:   '기생충',
  bacteria:   '세균',
  superVirus: '슈퍼 바이러스',
  monster:    '몬스터'
};
const enemyDescriptions = {
  virus:      '속도 빠르나 체력이 낮은 바이러스: 단일 목표에 빠르게 돌진합니다.',
  parasite:   '체력 높고 느리지만, 방어선을 오래 지연시키는 기생충입니다.',
  bacteria:   '속도·체력 모두 평균적인 균형형 적입니다.',
  superVirus: '5웨이브 보스: 고속·고화력 공격을 퍼붓는 슈퍼 바이러스입니다.',
  monster:    '최종 10웨이브 보스: 압도적 체력과 공격력의 몬스터 군단입니다.'
};

let selectedEnemy = null;
let ATP = 310;
let health = 5;
let wave = 0;
let enemiesToSpawn = 0;
let enemiesSpawned = 0;
let waveInProgress = false;
let interWave = true;
let spawnDone = false;
let interSeconds = 30;
let interTimer = null;
let spawnInterval = null;
let selectedCell = null;
let selectedUpgradeTarget = null;
let mouseX = 0, mouseY = 0;
let score = 0;
let firstWave = false;
let waveStartLock = false;
let highScore = parseInt(localStorage.getItem('gdh_highScore')) || 0;
highScoreDisplay.textContent = highScore;

const lines = [200, 400];
const cells = [];
const enemies = [];
const projectiles = [];

const baseCellTypes = {
  basic:  { damage:10, range:60, cooldownMax:50, cost:50, projectileSpeed:8 },
  neuron: { damage:7, range:100, cooldownMax:120, cost:80 },
  plant:  { hp:500, cost:60 }
};

const enemyTypes = [
  { type:'virus',   hp:30, speed:1.2, color:'#d22', size:20 },
  { type:'parasite',hp:50, speed:0.5, color:'#720072', size:30 },
  { type:'bacteria',hp:40, speed:0.9, color:'#ff6', size:25 }
];

function updateUIButtons() {
  const bCost = getPlacementCost('basic');
  const nCost = getPlacementCost('neuron');
  const pCost = getPlacementCost('plant');

  basicBtn.textContent  = `기본세포(${bCost})`;
  neuronBtn.textContent = `뉴런(${nCost})`;
  plantBtn.textContent  = `식물세포(${pCost})`;

  basicBtn.disabled   = ATP < bCost;
  neuronBtn.disabled  = ATP < nCost;
  plantBtn.disabled   = ATP < pCost;

  document.getElementById('cellCount').textContent = cells.length;

  startBtn.style.display = interWave ? 'inline-block' : 'none';
  timerDisplay.style.display = interWave ? 'inline-block' : 'none';

  atpDisplay.textContent      = ATP;
  healthDisplay.textContent   = health;
  waveDisplay.textContent     = wave;
  scoreDisplay.textContent    = `Score: ${score}`;
  highScoreDisplay.textContent= `HighScore: ${highScore}`;
  updateCellInfo();
}

basicBtn.onclick = () => selectCell('basic');
neuronBtn.onclick = () => selectCell('neuron');
plantBtn.onclick = () => selectCell('plant');
function selectCell(type) {
  selectedCell = type;
  selectedUpgradeTarget = null;
  [basicBtn, neuronBtn, plantBtn].forEach(b => b.style.background = '#0f0');
  document.getElementById(type+'Btn').style.background = '#0c0';
  updateUIButtons();
}

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = e.clientX - r.left;
  mouseY = e.clientY - r.top;
});
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  if (selectedCell) {
    if (cells.length >= MAX_CELLS) {
      showWaveBanner(`최대 ${MAX_CELLS}개까지만 설치 가능`);
      return;
    }
    const cost = getPlacementCost(selectedCell);
    if (ATP < cost) return;
    if (selectedCell==='plant' && !lines.some(L=>Math.abs(y-L)<=20)) return;
    if (selectedCell!=='plant' && lines.some(L=>Math.abs(y-L)<=20)) return;
    const cell = {
      x, y,
      type: selectedCell,
      cooldown: 0,
      hp: baseCellTypes[selectedCell].hp,
      maxHp: baseCellTypes[selectedCell].hp,
      damage: baseCellTypes[selectedCell].damage||0,
      range: baseCellTypes[selectedCell].range||0,
      upgrade: 0
    };
    if (selectedCell==='plant') { cell.width=40; cell.height=60; }
    cells.push(cell);
    ATP -= cost;
    selectedCell = null;
    [basicBtn, neuronBtn, plantBtn].forEach(b=>b.style.background='#0f0');
    updateUIButtons();
    updateCellInfo();
    return;
  }

  selectedUpgradeTarget = null;
  selectedEnemy = null;
  for (const en of enemies) {
    if (Math.hypot(x - en.x, y - en.y) <= en.size) {
      selectedEnemy = en;
      updateUIButtons();
      updateCellInfo();
      return;
    }
  }

  for (const c of cells) {
    const dx = x - c.x;
    const dy = y - c.y;
    const hit = (c.type==='plant') ? Math.abs(dx)<=20 && Math.abs(dy)<=30 : Math.hypot(dx,dy)<=20;
    if (hit) { selectedUpgradeTarget = c; break; }
  }
  updateUIButtons();
  updateCellInfo();
});

startBtn.onclick = () => {
  if (!interWave || waveStartLock) return;
  waveStartLock = true;
  if (interTimer) {
    clearInterval(interTimer);
    interTimer = null;
  }
  wave++;
  // 15웨이브 이후 게임 종료
  if (wave > 15) {
    showWaveBanner('게임 종료! 최종 점수: ' + score);
    cancelAnimationFrame(loopId);
    return;
  }
  interWave = false;
  waveInProgress = true;
  updateUIButtons();
  spawnWave();
};

function updateCellInfo() {
  const info = document.getElementById('cellInfo');

  // 1) 셀 배치 선택 시
  if (selectedCell) {
    const type = selectedCell;
    const names = { basic:'기본 세포', neuron:'뉴런', plant:'식물 세포' };
    const tpl  = baseCellTypes[type];
    const cost = getPlacementCost(type);
    let html = `
      <div><strong>설치 후보 ▶ ${names[type]}</strong></div>
      <div class="description">${cellDescriptions[type]}</div>
      <div>공격력: ${tpl.damage||0}</div>
      <div>사거리: ${tpl.range||0}</div>
      ${type==='plant'?`<div>체력: ${tpl.hp}</div>`:``}
      <div>설치 비용: ${cost}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 2) 적 클릭 시
  if (selectedEnemy) {
    const e    = selectedEnemy;
    const name = enemyNames[e.type];
    const desc = enemyDescriptions[e.type];
    let html = `
      <div><strong>적 ▶ ${name}</strong></div>
      <div class="description">${desc}</div>
      <div>체력: ${Math.round(e.hp)} / ${e.maxHp}</div>
      <div>속도: ${e.speed.toFixed(2)}</div>
      <div>공격력: ${e.damageToCell}</div>
    `;
    info.innerHTML = html;
    return;
  }

  // 3) 세포 클릭 시 업그레이드/삭제 버튼 활성화
  if (selectedUpgradeTarget) {
    const c    = selectedUpgradeTarget;
    const type = c.type;
    const names= { basic:'기본 세포', neuron:'뉴런', plant:'식물 세포' };
    const curr = { damage:c.damage||0, range:c.range||0, hp:c.maxHp||0 };
    const next = { ...curr };
    if (type==='basic')     { next.damage+=2;  next.range+=10; }
    else if (type==='neuron'){ next.damage+=1.5;next.range+=8; }
    else /* plant */        { next.hp+=30; }
    const cost = getUpgradeCost(c);

    let html = `
      <div><strong>종류: ${names[type]}</strong></div>
      <div class="description">${cellDescriptions[type]}</div>
      <div>공격력: ${curr.damage} → ${next.damage}</div>
      <div>사거리: ${curr.range} → ${next.range}</div>
      ${type==='plant'?`<div>체력: ${curr.hp} → ${next.hp}</div>`:``}
      <button id="cellUpgradeBtn" ${ATP<cost?'disabled':''}>레벨업 (${cost})</button>
      <button id="cellDeleteBtn" style="margin-left:8px;background:#f44;color:#fff;">이 세포 삭제</button>
    `;
    info.innerHTML = html;

    // 업그레이드 버튼 이벤트
    document.getElementById('cellUpgradeBtn').onclick = () => {
      const target = selectedUpgradeTarget;
      if (!target) return;
      if (ATP < cost) return;
      ATP -= cost;
      target.upgrade = (target.upgrade||0) + 1;
      if (c.type==='basic') {
        target.damage += 2;
        target.range  += 10;
      } else if (target.type==='neuron') {
        target.damage += 1.5;
        target.range  += 8;
      } else {
        target.hp     += 30;
        target.maxHp  += 30;
      }
      selectedUpgradeTarget = target;
      updateUIButtons();
      updateCellInfo();
    };
    // 삭제 버튼 이벤트
    document.getElementById('cellDeleteBtn').onclick = () => {
      const idx = cells.indexOf(selectedUpgradeTarget);
      if (idx !== -1) {
        cells.splice(idx, 1);
        selectedUpgradeTarget = null; // 먼저 null 처리
        updateUIButtons();            // info창도 같이 갱신
        showWaveBanner('세포 삭제됨');
      }
    };
    return;
  }
  info.innerHTML = '';
}

function spawnWave() {
  spawnDone = false;
  enemiesSpawned = 0;
  enemiesToSpawn = 5 + wave * 2;
  if (wave % 5 === 0) enemiesToSpawn = (5 + wave * 2) * 2;
  updateUIButtons();
  showWaveBanner(`Wave ${wave}`);
  spawnInterval = setInterval(spawnEnemy, Math.max(2000 - wave*150, 500));
  if (wave % 5 === 0) {
    const y = lines[Math.floor(Math.random() * lines.length)];
    enemies.push({
      type: wave===10 ? 'monster' : 'superVirus',
      x:0, y,
      hp: 200 + wave*20,
      maxHp: 200 + wave*20,
      speed: 0.8,
      color: '#ff0',
      size: 50,
      damageToCell: 3 + Math.floor(wave/5),
      blocked: false, blockTimer: 0
    });
  }
}

function spawnEnemy() {
  if (enemiesSpawned++ >= enemiesToSpawn) {
    clearInterval(spawnInterval);
    waveInProgress = false;
    spawnDone = true;
    return;
  }
  const base = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
  const y = lines[Math.floor(Math.random()*lines.length)];
  enemies.push({
    type: base.type,
    x:0, y,
    hp: base.hp + wave*5,
    maxHp: base.hp + wave*5,
    speed: base.speed + wave*0.05,
    color: base.color,
    size: base.size,
    damageToCell: 1 + Math.floor(wave/3),
    blocked: false, blockTimer: 0
  });
}

function getPlacementCost(type) {
  const base = baseCellTypes[type].cost;
  const count = cells.filter(c => c.type === type).length;
  return Math.max( Math.floor(base * (1 + count * 0.1)), base );
}
function getUpgradeCost(cell) {
  const base = 50;
  const lvl  = cell.upgrade || 0;
  return Math.floor(base * (1 + lvl * 0.5));
}

function startInterWave() {
  interWave = true;
  waveStartLock = false;
  ATP += (60 + wave * 30);

  const duration = 30 * 1000;
  const startTs  = Date.now();
  timerDisplay.textContent = `Upgrade Time: ${Math.ceil(duration/1000)}s`;
  updateUIButtons();

  interTimer = setInterval(() => {
    const elapsed = Date.now() - startTs;
    timerDisplay.textContent = `Upgrade Time: ${Math.ceil((duration-elapsed)/1000)}s`;
    if (elapsed >= duration) {
      clearInterval(interTimer);
      interTimer = null;
      startBtn.click();
    }
  }, 200);
}

function showWaveBanner(txt) {
  waveBanner.textContent = txt;
  waveBanner.style.opacity = 1;
  setTimeout(() => waveBanner.style.opacity = 0, 2000);
}

function drawHealthBar(x,y,w,h,hp,mh) { ctx.fillStyle='black';ctx.fillRect(x,y,w,h);ctx.fillStyle='lime';ctx.fillRect(x,y,w*(hp/mh),h);ctx.strokeStyle='white';ctx.strokeRect(x,y,w,h); }
function drawEnemyStats(e) { ctx.fillStyle='white';ctx.font='12px Arial';ctx.fillText(`HP:${Math.round(e.hp)}`,e.x-15,e.y-e.size-18);ctx.fillText(`DMG:${e.damageToCell}`,e.x-15,e.y-e.size-6); }
function drawElectricArc(x,y,ts) { ctx.strokeStyle='yellow';ctx.lineWidth=3;ts.forEach(t=>{ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(t.x,t.y);ctx.stroke();}); }

function drawCellImage(cell) {
  const evolved = cell.upgrade >= 5;
  if (cell.type === 'plant') {
    const img = evolved ? imgPlantEvo : imgPlant;
    ctx.drawImage(img, cell.x - 20, cell.y - 30, 40, 60);
  } else if (cell.type === 'basic') {
    const img = evolved ? imgCellEvo : imgCell;
    ctx.drawImage(img, cell.x - 20, cell.y - 20, 40, 40);
  } else if (cell.type === 'neuron') {
    const img = evolved ? imgNeuronEvo : imgNeuron;
    ctx.drawImage(img, cell.x - 20, cell.y - 20, 40, 40);
  }
}

function loop() {
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,800,600);
  ctx.globalAlpha = 1;
  if (selectedCell) {
    ctx.save(); ctx.globalAlpha = 0.3;
    if (selectedCell === 'plant') {
      ctx.drawImage(imgPlant, mouseX - 20, mouseY - 30, 40, 60);
    } else if (selectedCell === 'basic') {
      ctx.drawImage(imgCell, mouseX - 20, mouseY - 20, 40, 40);
    } else if (selectedCell === 'neuron') {
      ctx.drawImage(imgNeuron, mouseX - 20, mouseY - 20, 40, 40);
    }
    ctx.restore();
    const t = baseCellTypes[selectedCell];
    ctx.strokeStyle='white';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(mouseX,mouseY,t.range,0,Math.PI*2);ctx.stroke();
  }
  ctx.fillStyle = '#4a8';
  lines.forEach(y => {
    ctx.fillRect(0, y - 2, canvas.width, 4);
  });

  cells.forEach(cell => {
    drawCellImage(cell);
    ctx.fillStyle = 'white';
    ctx.font      = '12px Arial';
    ctx.fillText(`Lv.${cell.upgrade}`, cell.x - 12, cell.y + 30);
    if (cell.type === 'plant') {
      drawHealthBar(cell.x - 20, cell.y + 35, 40, 6, cell.hp, cell.maxHp);
    }
    if (cell === selectedUpgradeTarget) {
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth   = 2;
      ctx.beginPath();
      ctx.arc(cell.x, cell.y, cell.range, 0, Math.PI*2);
      ctx.stroke();
      ctx.save();
        ctx.strokeStyle = 'red';
        ctx.lineWidth   = 3;
        if (cell.type === 'plant') {
          ctx.strokeRect(cell.x - 24, cell.y - 34, 48, 68);
        } else {
          ctx.beginPath();
          ctx.arc(cell.x, cell.y, 26, 0, Math.PI*2);
          ctx.stroke();
        }
      ctx.restore();
    }
  });

  cells.forEach(cell=>{
    if(cell.type==='plant') return;
    if(cell.cooldown>0){ cell.cooldown--; return; }
    const type = baseCellTypes[cell.type];
    if(cell.type==='basic'){
      let target=null, minD=Infinity;
      enemies.forEach(e=>{
        const d=Math.hypot(e.x-cell.x,e.y-cell.y);
        if(d<=cell.range && d<minD){ minD=d; target=e; }
      });
      if(target){
        projectiles.push({x:cell.x,y:cell.y,target,damage:cell.damage,speed:type.projectileSpeed});
        cell.cooldown = type.cooldownMax;
      }
    } else if(cell.type==='neuron'){
      const hits = enemies.filter(e=>Math.hypot(e.x-cell.x,e.y-cell.y)<=cell.range);
      if(hits.length){
        hits.forEach(e=>e.hp-=cell.damage);
        cell.arcTargets=hits; cell.cooldown=type.cooldownMax;
      }
    }
  });

  enemies.forEach(e => {
    const speed = e.speed;
    let didCollide = false;
    for (const cell of cells) {
      const dx = e.x - cell.x;
      const dy = e.y - cell.y;
      if (
        cell.type === 'plant' &&
        Math.abs(dx) <= cell.width/2 + e.size &&
        Math.abs(dy) <= cell.height/2 + e.size*0.6
      ) {
        cell.hp -= e.damageToCell;
        if (cell.hp <= 0) cells.splice(cells.indexOf(cell), 1);
        e.x -= speed;
        didCollide = true;
        break;
      }
      if (
        cell.type !== 'plant' &&
        Math.hypot(dx, dy) < 25
      ) {
        cell.hp -= e.damageToCell;
        if (cell.hp <= 0) cells.splice(cells.indexOf(cell), 1);
      }
    }
    if (!didCollide) {
      e.x += speed;
    }
    if (e.type === 'superVirus') {
      e.animTick = (e.animTick || 0) + 1;
      if (e.animTick % 8 === 0) {
        e.animFrame = ((e.animFrame || 0) + 1) % superBacteriaFrames.length;
      }
      ctx.drawImage(
        superBacteriaFrames[e.animFrame || 0],
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    } else if (e.type === 'virus') {
      ctx.drawImage(
        imgVirusSprite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    } else if (e.type === 'parasite') {
      ctx.drawImage(
        imgParasite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    } else if (e.type === 'bacteria') {
      ctx.drawImage(
        imgBacteriophageSprite,
        e.x - e.size, e.y - e.size,
        e.size * 2, e.size * 2
      );
    }
    if (e === selectedEnemy) {
      ctx.save();
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth   = 3;
        ctx.beginPath();
        ctx.ellipse(e.x, e.y, e.size + 4, e.size * 0.6 + 4, 0, 0, Math.PI * 2);
        ctx.stroke();
      ctx.restore();
    }
    drawHealthBar(e.x - e.size, e.y - e.size - 10, e.size*2, 6, e.hp, e.maxHp);
    drawEnemyStats(e);
  });

  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    if(!p.target||p.target.hp<=0){ projectiles.splice(i,1); continue; }
    const dx=p.target.x-p.x, dy=p.target.y-p.y, d=Math.hypot(dx,dy);
    if(d<p.speed){
      p.target.hp-=p.damage; projectiles.splice(i,1);
    } else {
      p.x+=(dx/d)*p.speed; p.y+=(dy/d)*p.speed;
      ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
    }
  }
  cells.forEach(cell=>{
    if(cell.type==='neuron'&&cell.arcTargets&&cell.cooldown>0) drawElectricArc(cell.x,cell.y,cell.arcTargets);
  });

  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.hp<=0){ enemies.splice(i,1); score+=10; ATP+=20;}
    else if (e.x > 800) {
      health = Math.max(0, health - e.damageToCell);
      healthDisplay.textContent = health.toFixed(2);
      enemies.splice(i, 1);
      if (health <= 0) {
        showWaveBanner('게임 종료! 최종 점수: ' + score);
        cancelAnimationFrame(loopId);
        return;
      }
    }
  }

  if (!interWave && !waveInProgress && spawnDone && enemies.length === 0) {
    startInterWave();
  }

  updateUIButtons();
  loopId = requestAnimationFrame(loop);
}

interWave = true;
updateUIButtons();
waveDisplay.textContent = wave;
scoreDisplay.textContent = `Score: ${score}`;
loop();
  </script>
</body>
</html>